{
  "version": 3,
  "sources": ["../../@sinclair/typebox/build/import/type/registry/format.mjs", "../../@sinclair/typebox/build/import/type/registry/type.mjs", "../../@sinclair/typebox/build/import/type/symbols/symbols.mjs", "../../@sinclair/typebox/build/import/type/unsafe/unsafe.mjs", "../../@sinclair/typebox/build/import/type/error/error.mjs", "../../@sinclair/typebox/build/import/type/mapped/mapped-key.mjs", "../../@sinclair/typebox/build/import/type/mapped/mapped-result.mjs", "../../@sinclair/typebox/build/import/type/guard/value.mjs", "../../@sinclair/typebox/build/import/type/clone/value.mjs", "../../@sinclair/typebox/build/import/type/clone/type.mjs", "../../@sinclair/typebox/build/import/type/array/array.mjs", "../../@sinclair/typebox/build/import/type/async-iterator/async-iterator.mjs", "../../@sinclair/typebox/build/import/type/constructor/constructor.mjs", "../../@sinclair/typebox/build/import/type/function/function.mjs", "../../@sinclair/typebox/build/import/type/never/never.mjs", "../../@sinclair/typebox/build/import/type/guard/type.mjs", "../../@sinclair/typebox/build/import/type/discard/discard.mjs", "../../@sinclair/typebox/build/import/type/intersect/intersect-create.mjs", "../../@sinclair/typebox/build/import/type/intersect/intersect-evaluated.mjs", "../../@sinclair/typebox/build/import/type/intersect/intersect.mjs", "../../@sinclair/typebox/build/import/type/union/union-create.mjs", "../../@sinclair/typebox/build/import/type/union/union-evaluated.mjs", "../../@sinclair/typebox/build/import/type/union/union.mjs", "../../@sinclair/typebox/build/import/type/template-literal/parse.mjs", "../../@sinclair/typebox/build/import/type/template-literal/finite.mjs", "../../@sinclair/typebox/build/import/type/template-literal/generate.mjs", "../../@sinclair/typebox/build/import/type/literal/literal.mjs", "../../@sinclair/typebox/build/import/type/boolean/boolean.mjs", "../../@sinclair/typebox/build/import/type/bigint/bigint.mjs", "../../@sinclair/typebox/build/import/type/number/number.mjs", "../../@sinclair/typebox/build/import/type/string/string.mjs", "../../@sinclair/typebox/build/import/type/template-literal/syntax.mjs", "../../@sinclair/typebox/build/import/type/patterns/patterns.mjs", "../../@sinclair/typebox/build/import/type/template-literal/pattern.mjs", "../../@sinclair/typebox/build/import/type/template-literal/union.mjs", "../../@sinclair/typebox/build/import/type/template-literal/template-literal.mjs", "../../@sinclair/typebox/build/import/type/indexed/indexed-property-keys.mjs", "../../@sinclair/typebox/build/import/type/indexed/indexed-from-mapped-result.mjs", "../../@sinclair/typebox/build/import/type/indexed/indexed.mjs", "../../@sinclair/typebox/build/import/type/indexed/indexed-from-mapped-key.mjs", "../../@sinclair/typebox/build/import/type/iterator/iterator.mjs", "../../@sinclair/typebox/build/import/type/object/object.mjs", "../../@sinclair/typebox/build/import/type/promise/promise.mjs", "../../@sinclair/typebox/build/import/type/readonly/readonly.mjs", "../../@sinclair/typebox/build/import/type/readonly/readonly-from-mapped-result.mjs", "../../@sinclair/typebox/build/import/type/tuple/tuple.mjs", "../../@sinclair/typebox/build/import/type/sets/set.mjs", "../../@sinclair/typebox/build/import/type/mapped/mapped.mjs", "../../@sinclair/typebox/build/import/type/optional/optional-from-mapped-result.mjs", "../../@sinclair/typebox/build/import/type/optional/optional.mjs", "../../@sinclair/typebox/build/import/type/keyof/keyof-property-keys.mjs", "../../@sinclair/typebox/build/import/type/keyof/keyof-from-mapped-result.mjs", "../../@sinclair/typebox/build/import/type/keyof/keyof.mjs", "../../@sinclair/typebox/build/import/type/extends/extends-undefined.mjs", "../../@sinclair/typebox/build/import/type/any/any.mjs", "../../@sinclair/typebox/build/import/type/unknown/unknown.mjs", "../../@sinclair/typebox/build/import/type/extends/extends-check.mjs", "../../@sinclair/typebox/build/import/type/extends/extends-from-mapped-key.mjs", "../../@sinclair/typebox/build/import/type/extends/extends.mjs", "../../@sinclair/typebox/build/import/type/extends/extends-from-mapped-result.mjs"],
  "sourcesContent": ["/** A registry for user defined string formats */\nconst map = new Map();\n/** Returns the entries in this registry */\nexport function Entries() {\n    return new Map(map);\n}\n/** Clears all user defined string formats */\nexport function Clear() {\n    return map.clear();\n}\n/** Deletes a registered format */\nexport function Delete(format) {\n    return map.delete(format);\n}\n/** Returns true if the user defined string format exists */\nexport function Has(format) {\n    return map.has(format);\n}\n/** Sets a validation function for a user defined string format */\nexport function Set(format, func) {\n    map.set(format, func);\n}\n/** Gets a validation function for a user defined string format */\nexport function Get(format) {\n    return map.get(format);\n}\n", "/** A registry for user defined types */\nconst map = new Map();\n/** Returns the entries in this registry */\nexport function Entries() {\n    return new Map(map);\n}\n/** Clears all user defined types */\nexport function Clear() {\n    return map.clear();\n}\n/** Deletes a registered type */\nexport function Delete(kind) {\n    return map.delete(kind);\n}\n/** Returns true if this registry contains this kind */\nexport function Has(kind) {\n    return map.has(kind);\n}\n/** Sets a validation function for a user defined type */\nexport function Set(kind, func) {\n    map.set(kind, func);\n}\n/** Gets a custom validation function for a user defined type */\nexport function Get(kind) {\n    return map.get(kind);\n}\n", "/** Symbol key applied to transform types */\nexport const TransformKind = Symbol.for('TypeBox.Transform');\n/** Symbol key applied to readonly types */\nexport const ReadonlyKind = Symbol.for('TypeBox.Readonly');\n/** Symbol key applied to optional types */\nexport const OptionalKind = Symbol.for('TypeBox.Optional');\n/** Symbol key applied to types */\nexport const Hint = Symbol.for('TypeBox.Hint');\n/** Symbol key applied to types */\nexport const Kind = Symbol.for('TypeBox.Kind');\n", "import { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a Unsafe type that will infers as the generic argument T */\nexport function Unsafe(options = {}) {\n    return {\n        ...options,\n        [Kind]: options[Kind] ?? 'Unsafe',\n    };\n}\n", "/** The base Error type thrown for all TypeBox exceptions  */\nexport class TypeBoxError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\n", "import { Kind } from '../symbols/index.mjs';\n// prettier-ignore\nexport function MappedKey(T) {\n    return {\n        [Kind]: 'MappedKey',\n        keys: T\n    };\n}\n", "import { Kind } from '../symbols/index.mjs';\n// prettier-ignore\nexport function MappedResult(properties) {\n    return {\n        [Kind]: 'MappedResult',\n        properties\n    };\n}\n", "/** Returns true if this value is an async iterator */\nexport function IsAsyncIterator(value) {\n    return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.asyncIterator in value;\n}\n/** Returns true if this value is an array */\nexport function IsArray(value) {\n    return Array.isArray(value);\n}\n/** Returns true if this value is bigint */\nexport function IsBigInt(value) {\n    return typeof value === 'bigint';\n}\n/** Returns true if this value is a boolean */\nexport function IsBoolean(value) {\n    return typeof value === 'boolean';\n}\n/** Returns true if this value is a Date object */\nexport function IsDate(value) {\n    return value instanceof globalThis.Date;\n}\n/** Returns true if this value is a function */\nexport function IsFunction(value) {\n    return typeof value === 'function';\n}\n/** Returns true if this value is an iterator */\nexport function IsIterator(value) {\n    return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.iterator in value;\n}\n/** Returns true if this value is null */\nexport function IsNull(value) {\n    return value === null;\n}\n/** Returns true if this value is number */\nexport function IsNumber(value) {\n    return typeof value === 'number';\n}\n/** Returns true if this value is an object */\nexport function IsObject(value) {\n    return typeof value === 'object' && value !== null;\n}\n/** Returns true if this value is RegExp */\nexport function IsRegExp(value) {\n    return value instanceof globalThis.RegExp;\n}\n/** Returns true if this value is string */\nexport function IsString(value) {\n    return typeof value === 'string';\n}\n/** Returns true if this value is symbol */\nexport function IsSymbol(value) {\n    return typeof value === 'symbol';\n}\n/** Returns true if this value is a Uint8Array */\nexport function IsUint8Array(value) {\n    return value instanceof globalThis.Uint8Array;\n}\n/** Returns true if this value is undefined */\nexport function IsUndefined(value) {\n    return value === undefined;\n}\n", "import * as ValueGuard from '../guard/value.mjs';\nfunction ArrayType(value) {\n    return value.map((value) => Visit(value));\n}\nfunction DateType(value) {\n    return new Date(value.getTime());\n}\nfunction Uint8ArrayType(value) {\n    return new Uint8Array(value);\n}\nfunction RegExpType(value) {\n    return new RegExp(value.source, value.flags);\n}\nfunction ObjectType(value) {\n    const clonedProperties = Object.getOwnPropertyNames(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});\n    const clonedSymbols = Object.getOwnPropertySymbols(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});\n    return { ...clonedProperties, ...clonedSymbols };\n}\n// prettier-ignore\nfunction Visit(value) {\n    return (ValueGuard.IsArray(value) ? ArrayType(value) :\n        ValueGuard.IsDate(value) ? DateType(value) :\n            ValueGuard.IsUint8Array(value) ? Uint8ArrayType(value) :\n                ValueGuard.IsRegExp(value) ? RegExpType(value) :\n                    ValueGuard.IsObject(value) ? ObjectType(value) :\n                        value);\n}\n/** Clones a value */\nexport function Clone(value) {\n    return Visit(value);\n}\n", "import { Clone } from './value.mjs';\n/** Clones a Rest */\nexport function CloneRest(schemas) {\n    return schemas.map((schema) => CloneType(schema));\n}\n/** Clones a Type */\nexport function CloneType(schema, options = {}) {\n    return { ...Clone(schema), ...options };\n}\n", "import { CloneType } from '../clone/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates an Array type */\nexport function Array(schema, options = {}) {\n    return {\n        ...options,\n        [Kind]: 'Array',\n        type: 'array',\n        items: CloneType(schema),\n    };\n}\n", "import { Kind } from '../symbols/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\n/** `[JavaScript]` Creates a AsyncIterator type */\nexport function AsyncIterator(items, options = {}) {\n    return {\n        ...options,\n        [Kind]: 'AsyncIterator',\n        type: 'AsyncIterator',\n        items: CloneType(items),\n    };\n}\n", "import { CloneType, CloneRest } from '../clone/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[JavaScript]` Creates a Constructor type */\nexport function Constructor(parameters, returns, options) {\n    return {\n        ...options,\n        [Kind]: 'Constructor',\n        type: 'Constructor',\n        parameters: CloneRest(parameters),\n        returns: CloneType(returns),\n    };\n}\n", "import { CloneType, CloneRest } from '../clone/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[JavaScript]` Creates a Function type */\nexport function Function(parameters, returns, options) {\n    return {\n        ...options,\n        [Kind]: 'Function',\n        type: 'Function',\n        parameters: CloneRest(parameters),\n        returns: CloneType(returns),\n    };\n}\n", "import { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a Never type */\nexport function Never(options = {}) {\n    return {\n        ...options,\n        [Kind]: 'Never',\n        not: {},\n    };\n}\n", "import * as ValueGuard from './value.mjs';\nimport { Kind, Hint, TransformKind, ReadonlyKind, OptionalKind } from '../symbols/index.mjs';\nimport { TypeBoxError } from '../error/index.mjs';\nexport class TypeGuardUnknownTypeError extends TypeBoxError {\n}\nconst KnownTypes = [\n    'Any',\n    'Array',\n    'AsyncIterator',\n    'BigInt',\n    'Boolean',\n    'Constructor',\n    'Date',\n    'Enum',\n    'Function',\n    'Integer',\n    'Intersect',\n    'Iterator',\n    'Literal',\n    'MappedKey',\n    'MappedResult',\n    'Not',\n    'Null',\n    'Number',\n    'Object',\n    'Promise',\n    'Record',\n    'Ref',\n    'RegExp',\n    'String',\n    'Symbol',\n    'TemplateLiteral',\n    'This',\n    'Tuple',\n    'Undefined',\n    'Union',\n    'Uint8Array',\n    'Unknown',\n    'Void',\n];\nfunction IsPattern(value) {\n    try {\n        new RegExp(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nfunction IsControlCharacterFree(value) {\n    if (!ValueGuard.IsString(value))\n        return false;\n    for (let i = 0; i < value.length; i++) {\n        const code = value.charCodeAt(i);\n        if ((code >= 7 && code <= 13) || code === 27 || code === 127) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction IsAdditionalProperties(value) {\n    return IsOptionalBoolean(value) || IsSchema(value);\n}\nfunction IsOptionalBigInt(value) {\n    return ValueGuard.IsUndefined(value) || ValueGuard.IsBigInt(value);\n}\nfunction IsOptionalNumber(value) {\n    return ValueGuard.IsUndefined(value) || ValueGuard.IsNumber(value);\n}\nfunction IsOptionalBoolean(value) {\n    return ValueGuard.IsUndefined(value) || ValueGuard.IsBoolean(value);\n}\nfunction IsOptionalString(value) {\n    return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value);\n}\nfunction IsOptionalPattern(value) {\n    return ValueGuard.IsUndefined(value) || (ValueGuard.IsString(value) && IsControlCharacterFree(value) && IsPattern(value));\n}\nfunction IsOptionalFormat(value) {\n    return ValueGuard.IsUndefined(value) || (ValueGuard.IsString(value) && IsControlCharacterFree(value));\n}\nfunction IsOptionalSchema(value) {\n    return ValueGuard.IsUndefined(value) || IsSchema(value);\n}\n// ------------------------------------------------------------------\n// Modifiers\n// ------------------------------------------------------------------\n/** Returns true if this value has a Readonly symbol */\nexport function IsReadonly(value) {\n    return ValueGuard.IsObject(value) && value[ReadonlyKind] === 'Readonly';\n}\n/** Returns true if this value has a Optional symbol */\nexport function IsOptional(value) {\n    return ValueGuard.IsObject(value) && value[OptionalKind] === 'Optional';\n}\n// ------------------------------------------------------------------\n// Types\n// ------------------------------------------------------------------\n/** Returns true if the given value is TAny */\nexport function IsAny(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Any') &&\n        IsOptionalString(value.$id));\n}\n/** Returns true if the given value is TArray */\nexport function IsArray(value) {\n    return (IsKindOf(value, 'Array') &&\n        value.type === 'array' &&\n        IsOptionalString(value.$id) &&\n        IsSchema(value.items) &&\n        IsOptionalNumber(value.minItems) &&\n        IsOptionalNumber(value.maxItems) &&\n        IsOptionalBoolean(value.uniqueItems) &&\n        IsOptionalSchema(value.contains) &&\n        IsOptionalNumber(value.minContains) &&\n        IsOptionalNumber(value.maxContains));\n}\n/** Returns true if the given value is TAsyncIterator */\nexport function IsAsyncIterator(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'AsyncIterator') &&\n        value.type === 'AsyncIterator' &&\n        IsOptionalString(value.$id) &&\n        IsSchema(value.items));\n}\n/** Returns true if the given value is TBigInt */\nexport function IsBigInt(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'BigInt') &&\n        value.type === 'bigint' &&\n        IsOptionalString(value.$id) &&\n        IsOptionalBigInt(value.exclusiveMaximum) &&\n        IsOptionalBigInt(value.exclusiveMinimum) &&\n        IsOptionalBigInt(value.maximum) &&\n        IsOptionalBigInt(value.minimum) &&\n        IsOptionalBigInt(value.multipleOf));\n}\n/** Returns true if the given value is TBoolean */\nexport function IsBoolean(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Boolean') &&\n        value.type === 'boolean' &&\n        IsOptionalString(value.$id));\n}\n/** Returns true if the given value is TConstructor */\nexport function IsConstructor(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Constructor') &&\n        value.type === 'Constructor' &&\n        IsOptionalString(value.$id) &&\n        ValueGuard.IsArray(value.parameters) &&\n        value.parameters.every(schema => IsSchema(schema)) &&\n        IsSchema(value.returns));\n}\n/** Returns true if the given value is TDate */\nexport function IsDate(value) {\n    return (IsKindOf(value, 'Date') &&\n        value.type === 'Date' &&\n        IsOptionalString(value.$id) &&\n        IsOptionalNumber(value.exclusiveMaximumTimestamp) &&\n        IsOptionalNumber(value.exclusiveMinimumTimestamp) &&\n        IsOptionalNumber(value.maximumTimestamp) &&\n        IsOptionalNumber(value.minimumTimestamp) &&\n        IsOptionalNumber(value.multipleOfTimestamp));\n}\n/** Returns true if the given value is TFunction */\nexport function IsFunction(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Function') &&\n        value.type === 'Function' &&\n        IsOptionalString(value.$id) &&\n        ValueGuard.IsArray(value.parameters) &&\n        value.parameters.every(schema => IsSchema(schema)) &&\n        IsSchema(value.returns));\n}\n/** Returns true if the given value is TInteger */\nexport function IsInteger(value) {\n    return (IsKindOf(value, 'Integer') &&\n        value.type === 'integer' &&\n        IsOptionalString(value.$id) &&\n        IsOptionalNumber(value.exclusiveMaximum) &&\n        IsOptionalNumber(value.exclusiveMinimum) &&\n        IsOptionalNumber(value.maximum) &&\n        IsOptionalNumber(value.minimum) &&\n        IsOptionalNumber(value.multipleOf));\n}\n/** Returns true if the given schema is TProperties */\nexport function IsProperties(value) {\n    // prettier-ignore\n    return (ValueGuard.IsObject(value) &&\n        Object.entries(value).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema(schema)));\n}\n/** Returns true if the given value is TIntersect */\nexport function IsIntersect(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Intersect') &&\n        (ValueGuard.IsString(value.type) && value.type !== 'object' ? false : true) &&\n        ValueGuard.IsArray(value.allOf) &&\n        value.allOf.every(schema => IsSchema(schema) && !IsTransform(schema)) &&\n        IsOptionalString(value.type) &&\n        (IsOptionalBoolean(value.unevaluatedProperties) || IsOptionalSchema(value.unevaluatedProperties)) &&\n        IsOptionalString(value.$id));\n}\n/** Returns true if the given value is TIterator */\nexport function IsIterator(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Iterator') &&\n        value.type === 'Iterator' &&\n        IsOptionalString(value.$id) &&\n        IsSchema(value.items));\n}\n/** Returns true if the given value is a TKind with the given name. */\nexport function IsKindOf(value, kind) {\n    return ValueGuard.IsObject(value) && Kind in value && value[Kind] === kind;\n}\n/** Returns true if the given value is TLiteral<string> */\nexport function IsLiteralString(value) {\n    return IsLiteral(value) && ValueGuard.IsString(value.const);\n}\n/** Returns true if the given value is TLiteral<number> */\nexport function IsLiteralNumber(value) {\n    return IsLiteral(value) && ValueGuard.IsNumber(value.const);\n}\n/** Returns true if the given value is TLiteral<boolean> */\nexport function IsLiteralBoolean(value) {\n    return IsLiteral(value) && ValueGuard.IsBoolean(value.const);\n}\n/** Returns true if the given value is TLiteral */\nexport function IsLiteral(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Literal') &&\n        IsOptionalString(value.$id) && IsLiteralValue(value.const));\n}\n/** Returns true if the given value is a TLiteralValue */\nexport function IsLiteralValue(value) {\n    return ValueGuard.IsBoolean(value) || ValueGuard.IsNumber(value) || ValueGuard.IsString(value);\n}\n/** Returns true if the given value is a TMappedKey */\nexport function IsMappedKey(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'MappedKey') &&\n        ValueGuard.IsArray(value.keys) &&\n        value.keys.every(key => ValueGuard.IsNumber(key) || ValueGuard.IsString(key)));\n}\n/** Returns true if the given value is TMappedResult */\nexport function IsMappedResult(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'MappedResult') &&\n        IsProperties(value.properties));\n}\n/** Returns true if the given value is TNever */\nexport function IsNever(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Never') &&\n        ValueGuard.IsObject(value.not) &&\n        Object.getOwnPropertyNames(value.not).length === 0);\n}\n/** Returns true if the given value is TNot */\nexport function IsNot(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Not') &&\n        IsSchema(value.not));\n}\n/** Returns true if the given value is TNull */\nexport function IsNull(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Null') &&\n        value.type === 'null' &&\n        IsOptionalString(value.$id));\n}\n/** Returns true if the given value is TNumber */\nexport function IsNumber(value) {\n    return (IsKindOf(value, 'Number') &&\n        value.type === 'number' &&\n        IsOptionalString(value.$id) &&\n        IsOptionalNumber(value.exclusiveMaximum) &&\n        IsOptionalNumber(value.exclusiveMinimum) &&\n        IsOptionalNumber(value.maximum) &&\n        IsOptionalNumber(value.minimum) &&\n        IsOptionalNumber(value.multipleOf));\n}\n/** Returns true if the given value is TObject */\nexport function IsObject(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Object') &&\n        value.type === 'object' &&\n        IsOptionalString(value.$id) &&\n        IsProperties(value.properties) &&\n        IsAdditionalProperties(value.additionalProperties) &&\n        IsOptionalNumber(value.minProperties) &&\n        IsOptionalNumber(value.maxProperties));\n}\n/** Returns true if the given value is TPromise */\nexport function IsPromise(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Promise') &&\n        value.type === 'Promise' &&\n        IsOptionalString(value.$id) &&\n        IsSchema(value.item));\n}\n/** Returns true if the given value is TRecord */\nexport function IsRecord(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Record') &&\n        value.type === 'object' &&\n        IsOptionalString(value.$id) &&\n        IsAdditionalProperties(value.additionalProperties) &&\n        ValueGuard.IsObject(value.patternProperties) &&\n        ((schema) => {\n            const keys = Object.getOwnPropertyNames(schema.patternProperties);\n            return (keys.length === 1 &&\n                IsPattern(keys[0]) &&\n                ValueGuard.IsObject(schema.patternProperties) &&\n                IsSchema(schema.patternProperties[keys[0]]));\n        })(value));\n}\n/** Returns true if this value is TRecursive */\nexport function IsRecursive(value) {\n    return ValueGuard.IsObject(value) && Hint in value && value[Hint] === 'Recursive';\n}\n/** Returns true if the given value is TRef */\nexport function IsRef(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Ref') &&\n        IsOptionalString(value.$id) &&\n        ValueGuard.IsString(value.$ref));\n}\n/** Returns true if the given value is TRegExp */\nexport function IsRegExp(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'RegExp') &&\n        IsOptionalString(value.$id) &&\n        ValueGuard.IsString(value.source) &&\n        ValueGuard.IsString(value.flags) &&\n        IsOptionalNumber(value.maxLength) &&\n        IsOptionalNumber(value.minLength));\n}\n/** Returns true if the given value is TString */\nexport function IsString(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'String') &&\n        value.type === 'string' &&\n        IsOptionalString(value.$id) &&\n        IsOptionalNumber(value.minLength) &&\n        IsOptionalNumber(value.maxLength) &&\n        IsOptionalPattern(value.pattern) &&\n        IsOptionalFormat(value.format));\n}\n/** Returns true if the given value is TSymbol */\nexport function IsSymbol(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Symbol') &&\n        value.type === 'symbol' &&\n        IsOptionalString(value.$id));\n}\n/** Returns true if the given value is TTemplateLiteral */\nexport function IsTemplateLiteral(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'TemplateLiteral') &&\n        value.type === 'string' &&\n        ValueGuard.IsString(value.pattern) &&\n        value.pattern[0] === '^' &&\n        value.pattern[value.pattern.length - 1] === '$');\n}\n/** Returns true if the given value is TThis */\nexport function IsThis(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'This') &&\n        IsOptionalString(value.$id) &&\n        ValueGuard.IsString(value.$ref));\n}\n/** Returns true of this value is TTransform */\nexport function IsTransform(value) {\n    return ValueGuard.IsObject(value) && TransformKind in value;\n}\n/** Returns true if the given value is TTuple */\nexport function IsTuple(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Tuple') &&\n        value.type === 'array' &&\n        IsOptionalString(value.$id) &&\n        ValueGuard.IsNumber(value.minItems) &&\n        ValueGuard.IsNumber(value.maxItems) &&\n        value.minItems === value.maxItems &&\n        (( // empty\n        ValueGuard.IsUndefined(value.items) &&\n            ValueGuard.IsUndefined(value.additionalItems) &&\n            value.minItems === 0) || (ValueGuard.IsArray(value.items) &&\n            value.items.every(schema => IsSchema(schema)))));\n}\n/** Returns true if the given value is TUndefined */\nexport function IsUndefined(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Undefined') &&\n        value.type === 'undefined' &&\n        IsOptionalString(value.$id));\n}\n/** Returns true if the given value is TUnion<Literal<string | number>[]> */\nexport function IsUnionLiteral(value) {\n    return IsUnion(value) && value.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));\n}\n/** Returns true if the given value is TUnion */\nexport function IsUnion(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Union') &&\n        IsOptionalString(value.$id) &&\n        ValueGuard.IsObject(value) &&\n        ValueGuard.IsArray(value.anyOf) &&\n        value.anyOf.every(schema => IsSchema(schema)));\n}\n/** Returns true if the given value is TUint8Array */\nexport function IsUint8Array(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Uint8Array') &&\n        value.type === 'Uint8Array' &&\n        IsOptionalString(value.$id) &&\n        IsOptionalNumber(value.minByteLength) &&\n        IsOptionalNumber(value.maxByteLength));\n}\n/** Returns true if the given value is TUnknown */\nexport function IsUnknown(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Unknown') &&\n        IsOptionalString(value.$id));\n}\n/** Returns true if the given value is a raw TUnsafe */\nexport function IsUnsafe(value) {\n    return IsKindOf(value, 'Unsafe');\n}\n/** Returns true if the given value is TVoid */\nexport function IsVoid(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Void') &&\n        value.type === 'void' &&\n        IsOptionalString(value.$id));\n}\n/** Returns true if the given value is TKind */\nexport function IsKind(value) {\n    return ValueGuard.IsObject(value) && Kind in value && ValueGuard.IsString(value[Kind]) && !KnownTypes.includes(value[Kind]);\n}\n/** Returns true if the given value is TSchema */\nexport function IsSchema(value) {\n    // prettier-ignore\n    return (ValueGuard.IsObject(value)) && (IsAny(value) ||\n        IsArray(value) ||\n        IsBoolean(value) ||\n        IsBigInt(value) ||\n        IsAsyncIterator(value) ||\n        IsConstructor(value) ||\n        IsDate(value) ||\n        IsFunction(value) ||\n        IsInteger(value) ||\n        IsIntersect(value) ||\n        IsIterator(value) ||\n        IsLiteral(value) ||\n        IsMappedKey(value) ||\n        IsMappedResult(value) ||\n        IsNever(value) ||\n        IsNot(value) ||\n        IsNull(value) ||\n        IsNumber(value) ||\n        IsObject(value) ||\n        IsPromise(value) ||\n        IsRecord(value) ||\n        IsRef(value) ||\n        IsRegExp(value) ||\n        IsString(value) ||\n        IsSymbol(value) ||\n        IsTemplateLiteral(value) ||\n        IsThis(value) ||\n        IsTuple(value) ||\n        IsUndefined(value) ||\n        IsUnion(value) ||\n        IsUint8Array(value) ||\n        IsUnknown(value) ||\n        IsUnsafe(value) ||\n        IsVoid(value) ||\n        IsKind(value));\n}\n", "function DiscardKey(value, key) {\n    const { [key]: _, ...rest } = value;\n    return rest;\n}\nexport function Discard(value, keys) {\n    return keys.reduce((acc, key) => DiscardKey(acc, key), value);\n}\n", "import { Kind } from '../symbols/index.mjs';\nimport { CloneType, CloneRest } from '../clone/type.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsObject, IsSchema } from '../guard/type.mjs';\n// ------------------------------------------------------------------\n// IntersectCreate\n// ------------------------------------------------------------------\n// prettier-ignore\nexport function IntersectCreate(T, options) {\n    const allObjects = T.every((schema) => IsObject(schema));\n    const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties)\n        ? { unevaluatedProperties: CloneType(options.unevaluatedProperties) }\n        : {};\n    return ((options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects\n        ? { ...options, ...clonedUnevaluatedProperties, [Kind]: 'Intersect', type: 'object', allOf: CloneRest(T) }\n        : { ...options, ...clonedUnevaluatedProperties, [Kind]: 'Intersect', allOf: CloneRest(T) }));\n}\n", "import { OptionalKind } from '../symbols/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\nimport { Discard } from '../discard/index.mjs';\nimport { Never } from '../never/index.mjs';\nimport { Optional } from '../optional/index.mjs';\nimport { IntersectCreate } from './intersect-create.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\n// prettier-ignore\nimport { IsOptional, IsTransform, } from '../guard/type.mjs';\n// prettier-ignore\nfunction IsIntersectOptional(T) {\n    return T.every(L => IsOptional(L));\n}\n// prettier-ignore\nfunction RemoveOptionalFromType(T) {\n    return (Discard(T, [OptionalKind]));\n}\n// prettier-ignore\nfunction RemoveOptionalFromRest(T) {\n    return T.map(L => IsOptional(L) ? RemoveOptionalFromType(L) : L);\n}\n// prettier-ignore\nfunction ResolveIntersect(T, options) {\n    return (IsIntersectOptional(T)\n        ? Optional(IntersectCreate(RemoveOptionalFromRest(T), options))\n        : IntersectCreate(RemoveOptionalFromRest(T), options));\n}\n/** `[Json]` Creates an evaluated Intersect type */\nexport function IntersectEvaluated(T, options = {}) {\n    if (T.length === 0)\n        return Never(options);\n    if (T.length === 1)\n        return CloneType(T[0], options);\n    if (T.some((schema) => IsTransform(schema)))\n        throw new Error('Cannot intersect transform types');\n    return ResolveIntersect(T, options);\n}\n", "import { CloneType } from '../clone/type.mjs';\nimport { Never } from '../never/index.mjs';\nimport { IntersectCreate } from './intersect-create.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsTransform } from '../guard/type.mjs';\n/** `[Json]` Creates an evaluated Intersect type */\nexport function Intersect(T, options = {}) {\n    if (T.length === 0)\n        return Never(options);\n    if (T.length === 1)\n        return CloneType(T[0], options);\n    if (T.some((schema) => IsTransform(schema)))\n        throw new Error('Cannot intersect transform types');\n    return IntersectCreate(T, options);\n}\n", "import { CloneRest } from '../clone/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\nexport function UnionCreate(T, options) {\n    return { ...options, [Kind]: 'Union', anyOf: CloneRest(T) };\n}\n", "import { OptionalKind } from '../symbols/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\nimport { Discard } from '../discard/index.mjs';\nimport { Never } from '../never/index.mjs';\nimport { Optional } from '../optional/index.mjs';\nimport { UnionCreate } from './union-create.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsOptional } from '../guard/type.mjs';\n// prettier-ignore\nfunction IsUnionOptional(T) {\n    return T.some(L => IsOptional(L));\n}\n// prettier-ignore\nfunction RemoveOptionalFromRest(T) {\n    return T.map(L => IsOptional(L) ? RemoveOptionalFromType(L) : L);\n}\n// prettier-ignore\nfunction RemoveOptionalFromType(T) {\n    return (Discard(T, [OptionalKind]));\n}\n// prettier-ignore\nfunction ResolveUnion(T, options) {\n    return (IsUnionOptional(T)\n        ? Optional(UnionCreate(RemoveOptionalFromRest(T), options))\n        : UnionCreate(RemoveOptionalFromRest(T), options));\n}\n/** `[Json]` Creates an evaluated Union type */\nexport function UnionEvaluated(T, options = {}) {\n    // prettier-ignore\n    return (T.length === 0 ? Never(options) :\n        T.length === 1 ? CloneType(T[0], options) :\n            ResolveUnion(T, options));\n}\n", "import { Never } from '../never/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\nimport { UnionCreate } from './union-create.mjs';\n/** `[Json]` Creates a Union type */\nexport function Union(T, options = {}) {\n    // prettier-ignore\n    return (T.length === 0 ? Never(options) :\n        T.length === 1 ? CloneType(T[0], options) :\n            UnionCreate(T, options));\n}\n", "import { TypeBoxError } from '../error/index.mjs';\n// ------------------------------------------------------------------\n// TemplateLiteralParserError\n// ------------------------------------------------------------------\nexport class TemplateLiteralParserError extends TypeBoxError {\n}\n// prettier-ignore\nfunction IsNonEscaped(pattern, index, char) {\n    return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;\n}\n// prettier-ignore\nfunction IsOpenParen(pattern, index) {\n    return IsNonEscaped(pattern, index, '(');\n}\n// prettier-ignore\nfunction IsCloseParen(pattern, index) {\n    return IsNonEscaped(pattern, index, ')');\n}\n// prettier-ignore\nfunction IsSeparator(pattern, index) {\n    return IsNonEscaped(pattern, index, '|');\n}\n// prettier-ignore\nfunction IsGroup(pattern) {\n    if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))\n        return false;\n    let count = 0;\n    for (let index = 0; index < pattern.length; index++) {\n        if (IsOpenParen(pattern, index))\n            count += 1;\n        if (IsCloseParen(pattern, index))\n            count -= 1;\n        if (count === 0 && index !== pattern.length - 1)\n            return false;\n    }\n    return true;\n}\n// prettier-ignore\nfunction InGroup(pattern) {\n    return pattern.slice(1, pattern.length - 1);\n}\n// prettier-ignore\nfunction IsPrecedenceOr(pattern) {\n    let count = 0;\n    for (let index = 0; index < pattern.length; index++) {\n        if (IsOpenParen(pattern, index))\n            count += 1;\n        if (IsCloseParen(pattern, index))\n            count -= 1;\n        if (IsSeparator(pattern, index) && count === 0)\n            return true;\n    }\n    return false;\n}\n// prettier-ignore\nfunction IsPrecedenceAnd(pattern) {\n    for (let index = 0; index < pattern.length; index++) {\n        if (IsOpenParen(pattern, index))\n            return true;\n    }\n    return false;\n}\n// prettier-ignore\nfunction Or(pattern) {\n    let [count, start] = [0, 0];\n    const expressions = [];\n    for (let index = 0; index < pattern.length; index++) {\n        if (IsOpenParen(pattern, index))\n            count += 1;\n        if (IsCloseParen(pattern, index))\n            count -= 1;\n        if (IsSeparator(pattern, index) && count === 0) {\n            const range = pattern.slice(start, index);\n            if (range.length > 0)\n                expressions.push(TemplateLiteralParse(range));\n            start = index + 1;\n        }\n    }\n    const range = pattern.slice(start);\n    if (range.length > 0)\n        expressions.push(TemplateLiteralParse(range));\n    if (expressions.length === 0)\n        return { type: 'const', const: '' };\n    if (expressions.length === 1)\n        return expressions[0];\n    return { type: 'or', expr: expressions };\n}\n// prettier-ignore\nfunction And(pattern) {\n    function Group(value, index) {\n        if (!IsOpenParen(value, index))\n            throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);\n        let count = 0;\n        for (let scan = index; scan < value.length; scan++) {\n            if (IsOpenParen(value, scan))\n                count += 1;\n            if (IsCloseParen(value, scan))\n                count -= 1;\n            if (count === 0)\n                return [index, scan];\n        }\n        throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);\n    }\n    function Range(pattern, index) {\n        for (let scan = index; scan < pattern.length; scan++) {\n            if (IsOpenParen(pattern, scan))\n                return [index, scan];\n        }\n        return [index, pattern.length];\n    }\n    const expressions = [];\n    for (let index = 0; index < pattern.length; index++) {\n        if (IsOpenParen(pattern, index)) {\n            const [start, end] = Group(pattern, index);\n            const range = pattern.slice(start, end + 1);\n            expressions.push(TemplateLiteralParse(range));\n            index = end;\n        }\n        else {\n            const [start, end] = Range(pattern, index);\n            const range = pattern.slice(start, end);\n            if (range.length > 0)\n                expressions.push(TemplateLiteralParse(range));\n            index = end - 1;\n        }\n    }\n    return ((expressions.length === 0) ? { type: 'const', const: '' } :\n        (expressions.length === 1) ? expressions[0] :\n            { type: 'and', expr: expressions });\n}\n// ------------------------------------------------------------------\n// TemplateLiteralParse\n// ------------------------------------------------------------------\n/** Parses a pattern and returns an expression tree */\nexport function TemplateLiteralParse(pattern) {\n    // prettier-ignore\n    return (IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) :\n        IsPrecedenceOr(pattern) ? Or(pattern) :\n            IsPrecedenceAnd(pattern) ? And(pattern) :\n                { type: 'const', const: pattern });\n}\n// ------------------------------------------------------------------\n// TemplateLiteralParseExact\n// ------------------------------------------------------------------\n/** Parses a pattern and strips forward and trailing ^ and $ */\nexport function TemplateLiteralParseExact(pattern) {\n    return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));\n}\n", "import { TemplateLiteralParseExact } from './parse.mjs';\nimport { TypeBoxError } from '../error/index.mjs';\n// ------------------------------------------------------------------\n// TemplateLiteralFiniteError\n// ------------------------------------------------------------------\nexport class TemplateLiteralFiniteError extends TypeBoxError {\n}\n// ------------------------------------------------------------------\n// IsTemplateLiteralFiniteCheck\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction IsNumberExpression(expression) {\n    return (expression.type === 'or' &&\n        expression.expr.length === 2 &&\n        expression.expr[0].type === 'const' &&\n        expression.expr[0].const === '0' &&\n        expression.expr[1].type === 'const' &&\n        expression.expr[1].const === '[1-9][0-9]*');\n}\n// prettier-ignore\nfunction IsBooleanExpression(expression) {\n    return (expression.type === 'or' &&\n        expression.expr.length === 2 &&\n        expression.expr[0].type === 'const' &&\n        expression.expr[0].const === 'true' &&\n        expression.expr[1].type === 'const' &&\n        expression.expr[1].const === 'false');\n}\n// prettier-ignore\nfunction IsStringExpression(expression) {\n    return expression.type === 'const' && expression.const === '.*';\n}\n// ------------------------------------------------------------------\n// IsTemplateLiteralExpressionFinite\n// ------------------------------------------------------------------\n// prettier-ignore\nexport function IsTemplateLiteralExpressionFinite(expression) {\n    return (IsNumberExpression(expression) || IsStringExpression(expression) ? false :\n        IsBooleanExpression(expression) ? true :\n            (expression.type === 'and') ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) :\n                (expression.type === 'or') ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) :\n                    (expression.type === 'const') ? true :\n                        (() => { throw new TemplateLiteralFiniteError(`Unknown expression type`); })());\n}\n/** Returns true if this TemplateLiteral resolves to a finite set of values */\nexport function IsTemplateLiteralFinite(schema) {\n    const expression = TemplateLiteralParseExact(schema.pattern);\n    return IsTemplateLiteralExpressionFinite(expression);\n}\n", "import { IsTemplateLiteralExpressionFinite } from './finite.mjs';\nimport { TemplateLiteralParseExact } from './parse.mjs';\nimport { TypeBoxError } from '../error/index.mjs';\n// ------------------------------------------------------------------\n// TemplateLiteralGenerateError\n// ------------------------------------------------------------------\nexport class TemplateLiteralGenerateError extends TypeBoxError {\n}\n// ------------------------------------------------------------------\n// TemplateLiteralExpressionGenerate\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction* GenerateReduce(buffer) {\n    if (buffer.length === 1)\n        return yield* buffer[0];\n    for (const left of buffer[0]) {\n        for (const right of GenerateReduce(buffer.slice(1))) {\n            yield `${left}${right}`;\n        }\n    }\n}\n// prettier-ignore\nfunction* GenerateAnd(expression) {\n    return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));\n}\n// prettier-ignore\nfunction* GenerateOr(expression) {\n    for (const expr of expression.expr)\n        yield* TemplateLiteralExpressionGenerate(expr);\n}\n// prettier-ignore\nfunction* GenerateConst(expression) {\n    return yield expression.const;\n}\nexport function* TemplateLiteralExpressionGenerate(expression) {\n    return expression.type === 'and'\n        ? yield* GenerateAnd(expression)\n        : expression.type === 'or'\n            ? yield* GenerateOr(expression)\n            : expression.type === 'const'\n                ? yield* GenerateConst(expression)\n                : (() => {\n                    throw new TemplateLiteralGenerateError('Unknown expression');\n                })();\n}\n/** Generates a tuple of strings from the given TemplateLiteral. Returns an empty tuple if infinite. */\nexport function TemplateLiteralGenerate(schema) {\n    const expression = TemplateLiteralParseExact(schema.pattern);\n    // prettier-ignore\n    return (IsTemplateLiteralExpressionFinite(expression)\n        ? [...TemplateLiteralExpressionGenerate(expression)]\n        : []);\n}\n", "import { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a Literal type */\nexport function Literal(value, options = {}) {\n    return {\n        ...options,\n        [Kind]: 'Literal',\n        const: value,\n        type: typeof value,\n    };\n}\n", "import { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a Boolean type */\nexport function Boolean(options = {}) {\n    return {\n        ...options,\n        [Kind]: 'Boolean',\n        type: 'boolean',\n    };\n}\n", "import { Kind } from '../symbols/index.mjs';\n/** `[JavaScript]` Creates a BigInt type */\nexport function BigInt(options = {}) {\n    return {\n        ...options,\n        [Kind]: 'BigInt',\n        type: 'bigint',\n    };\n}\n", "import { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a Number type */\nexport function Number(options = {}) {\n    return {\n        ...options,\n        [Kind]: 'Number',\n        type: 'number',\n    };\n}\n", "import { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a String type */\nexport function String(options = {}) {\n    return { ...options, [Kind]: 'String', type: 'string' };\n}\n", "import { Literal } from '../literal/index.mjs';\nimport { Boolean } from '../boolean/index.mjs';\nimport { BigInt } from '../bigint/index.mjs';\nimport { Number } from '../number/index.mjs';\nimport { String } from '../string/index.mjs';\nimport { UnionEvaluated } from '../union/index.mjs';\nimport { Never } from '../never/index.mjs';\n// ------------------------------------------------------------------\n// SyntaxParsers\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction* FromUnion(syntax) {\n    const trim = syntax.trim().replace(/\"|'/g, '');\n    return (trim === 'boolean' ? yield Boolean() :\n        trim === 'number' ? yield Number() :\n            trim === 'bigint' ? yield BigInt() :\n                trim === 'string' ? yield String() :\n                    yield (() => {\n                        const literals = trim.split('|').map((literal) => Literal(literal.trim()));\n                        return (literals.length === 0 ? Never() :\n                            literals.length === 1 ? literals[0] :\n                                UnionEvaluated(literals));\n                    })());\n}\n// prettier-ignore\nfunction* FromTerminal(syntax) {\n    if (syntax[1] !== '{') {\n        const L = Literal('$');\n        const R = FromSyntax(syntax.slice(1));\n        return yield* [L, ...R];\n    }\n    for (let i = 2; i < syntax.length; i++) {\n        if (syntax[i] === '}') {\n            const L = FromUnion(syntax.slice(2, i));\n            const R = FromSyntax(syntax.slice(i + 1));\n            return yield* [...L, ...R];\n        }\n    }\n    yield Literal(syntax);\n}\n// prettier-ignore\nfunction* FromSyntax(syntax) {\n    for (let i = 0; i < syntax.length; i++) {\n        if (syntax[i] === '$') {\n            const L = Literal(syntax.slice(0, i));\n            const R = FromTerminal(syntax.slice(i));\n            return yield* [L, ...R];\n        }\n    }\n    yield Literal(syntax);\n}\n/** Parses TemplateLiteralSyntax and returns a tuple of TemplateLiteralKinds */\nexport function TemplateLiteralSyntax(syntax) {\n    return [...FromSyntax(syntax)];\n}\n", "export const PatternBoolean = '(true|false)';\nexport const PatternNumber = '(0|[1-9][0-9]*)';\nexport const PatternString = '(.*)';\nexport const PatternBooleanExact = `^${PatternBoolean}$`;\nexport const PatternNumberExact = `^${PatternNumber}$`;\nexport const PatternStringExact = `^${PatternString}$`;\n", "import { PatternNumber, PatternString, PatternBoolean } from '../patterns/index.mjs';\nimport { Kind } from '../symbols/index.mjs';\nimport { TypeBoxError } from '../error/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\n// prettier-ignore\nimport { IsTemplateLiteral, IsUnion, IsNumber, IsInteger, IsBigInt, IsString, IsLiteral, IsBoolean } from '../guard/type.mjs';\n// ------------------------------------------------------------------\n// TemplateLiteralPatternError\n// ------------------------------------------------------------------\nexport class TemplateLiteralPatternError extends TypeBoxError {\n}\n// ------------------------------------------------------------------\n// TemplateLiteralPattern\n// ------------------------------------------------------------------\nfunction Escape(value) {\n    return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n// prettier-ignore\nfunction Visit(schema, acc) {\n    return (IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) :\n        IsUnion(schema) ? `(${schema.anyOf.map((schema) => Visit(schema, acc)).join('|')})` :\n            IsNumber(schema) ? `${acc}${PatternNumber}` :\n                IsInteger(schema) ? `${acc}${PatternNumber}` :\n                    IsBigInt(schema) ? `${acc}${PatternNumber}` :\n                        IsString(schema) ? `${acc}${PatternString}` :\n                            IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` :\n                                IsBoolean(schema) ? `${acc}${PatternBoolean}` :\n                                    (() => { throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`); })());\n}\nexport function TemplateLiteralPattern(kinds) {\n    return `^${kinds.map((schema) => Visit(schema, '')).join('')}\\$`;\n}\n", "import { UnionEvaluated } from '../union/index.mjs';\nimport { Literal } from '../literal/index.mjs';\nimport { TemplateLiteralGenerate } from './generate.mjs';\n/** Returns a Union from the given TemplateLiteral */\nexport function TemplateLiteralToUnion(schema) {\n    const R = TemplateLiteralGenerate(schema);\n    const L = R.map((S) => Literal(S));\n    return UnionEvaluated(L);\n}\n", "import { TemplateLiteralSyntax } from './syntax.mjs';\nimport { TemplateLiteralPattern } from './pattern.mjs';\nimport { IsString } from '../guard/value.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a TemplateLiteral type */\n// prettier-ignore\nexport function TemplateLiteral(unresolved, options = {}) {\n    const pattern = IsString(unresolved)\n        ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved))\n        : TemplateLiteralPattern(unresolved);\n    return { ...options, [Kind]: 'TemplateLiteral', type: 'string', pattern };\n}\n", "import { TemplateLiteralGenerate } from '../template-literal/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsTemplateLiteral, IsUnion, IsLiteral, IsNumber, IsInteger } from '../guard/type.mjs';\n// prettier-ignore\nfunction FromTemplateLiteral(T) {\n    const R = TemplateLiteralGenerate(T);\n    return R.map(S => S.toString());\n}\n// prettier-ignore\nfunction FromUnion(T) {\n    return T.reduce((Acc, L) => {\n        return [...Acc, ...IndexPropertyKeys(L)];\n    }, []);\n}\n// prettier-ignore\nfunction FromLiteral(T) {\n    return ([T.toString()] // TS 5.4 observes TLiteralValue as not having a toString()\n    );\n}\n/** Returns a tuple of PropertyKeys derived from the given TSchema */\n// prettier-ignore\nexport function IndexPropertyKeys(T) {\n    return [...new Set((IsTemplateLiteral(T) ? FromTemplateLiteral(T) :\n            IsUnion(T) ? FromUnion(T.anyOf) :\n                IsLiteral(T) ? FromLiteral(T.const) :\n                    IsNumber(T) ? ['[number]'] :\n                        IsInteger(T) ? ['[number]'] :\n                            []))];\n}\n", "import { MappedResult } from '../mapped/index.mjs';\nimport { IndexPropertyKeys } from './indexed-property-keys.mjs';\nimport { Index } from './index.mjs';\n// prettier-ignore\nfunction FromProperties(T, P, options) {\n    return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {\n        return { ...Acc, [K2]: Index(T, IndexPropertyKeys(P[K2]), options) };\n    }, {});\n}\n// prettier-ignore\nfunction FromMappedResult(T, R, options) {\n    return FromProperties(T, R.properties, options);\n}\n// prettier-ignore\nexport function IndexFromMappedResult(T, R, options) {\n    const P = FromMappedResult(T, R, options);\n    return MappedResult(P);\n}\n", "import { Never } from '../never/index.mjs';\nimport { IntersectEvaluated } from '../intersect/index.mjs';\nimport { UnionEvaluated } from '../union/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\nimport { IndexPropertyKeys } from './indexed-property-keys.mjs';\nimport { IndexFromMappedKey } from './indexed-from-mapped-key.mjs';\nimport { IndexFromMappedResult } from './indexed-from-mapped-result.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsArray, IsIntersect, IsObject, IsMappedKey, IsMappedResult, IsNever, IsSchema, IsTuple, IsUnion } from '../guard/type.mjs';\n// prettier-ignore\nfunction FromRest(T, K) {\n    return T.map(L => IndexFromPropertyKey(L, K));\n}\n// prettier-ignore\nfunction FromIntersectRest(T) {\n    return T.filter(L => !IsNever(L));\n}\n// prettier-ignore\nfunction FromIntersect(T, K) {\n    return (IntersectEvaluated(FromIntersectRest(FromRest(T, K))));\n}\n// prettier-ignore\nfunction FromUnionRest(T) {\n    return T; // review this\n}\n// prettier-ignore\nfunction FromUnion(T, K) {\n    return (UnionEvaluated(FromUnionRest(FromRest(T, K))));\n}\n// prettier-ignore\nfunction FromTuple(T, K) {\n    return (K in T ? T[K] :\n        K === '[number]' ? UnionEvaluated(T) :\n            Never());\n}\n// prettier-ignore\nfunction FromArray(T, K) {\n    return (K === '[number]'\n        ? T\n        : Never());\n}\n// prettier-ignore\nfunction FromProperty(T, K) {\n    return (K in T ? T[K] : Never());\n}\n// prettier-ignore\nexport function IndexFromPropertyKey(T, K) {\n    return (IsIntersect(T) ? FromIntersect(T.allOf, K) :\n        IsUnion(T) ? FromUnion(T.anyOf, K) :\n            IsTuple(T) ? FromTuple(T.items ?? [], K) :\n                IsArray(T) ? FromArray(T.items, K) :\n                    IsObject(T) ? FromProperty(T.properties, K) :\n                        Never());\n}\n// prettier-ignore\nexport function IndexFromPropertyKeys(T, K) {\n    return K.map(L => IndexFromPropertyKey(T, L));\n}\n// prettier-ignore\nfunction FromSchema(T, K) {\n    return (UnionEvaluated(IndexFromPropertyKeys(T, K)));\n}\n/** `[Json]` Returns an Indexed property type for the given keys */\nexport function Index(T, K, options = {}) {\n    // prettier-ignore\n    return (IsMappedResult(K) ? CloneType(IndexFromMappedResult(T, K, options)) :\n        IsMappedKey(K) ? CloneType(IndexFromMappedKey(T, K, options)) :\n            IsSchema(K) ? CloneType(FromSchema(T, IndexPropertyKeys(K)), options) :\n                CloneType(FromSchema(T, K), options));\n}\n", "import { Index } from './indexed.mjs';\nimport { MappedResult } from '../mapped/index.mjs';\n// prettier-ignore\nfunction MappedIndexPropertyKey(T, K, options) {\n    return { [K]: Index(T, [K], options) };\n}\n// prettier-ignore\nfunction MappedIndexPropertyKeys(T, K, options) {\n    return K.reduce((Acc, L) => {\n        return { ...Acc, ...MappedIndexPropertyKey(T, L, options) };\n    }, {});\n}\n// prettier-ignore\nfunction MappedIndexProperties(T, K, options) {\n    return MappedIndexPropertyKeys(T, K.keys, options);\n}\n// prettier-ignore\nexport function IndexFromMappedKey(T, K, options) {\n    const P = MappedIndexProperties(T, K, options);\n    return MappedResult(P);\n}\n", "import { CloneType } from '../clone/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[JavaScript]` Creates an Iterator type */\nexport function Iterator(items, options = {}) {\n    return {\n        ...options,\n        [Kind]: 'Iterator',\n        type: 'Iterator',\n        items: CloneType(items),\n    };\n}\n", "import { CloneType } from '../clone/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsOptional, IsSchema } from '../guard/type.mjs';\n/** `[Json]` Creates an Object type */\nfunction _Object(properties, options = {}) {\n    const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);\n    const optionalKeys = propertyKeys.filter((key) => IsOptional(properties[key]));\n    const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));\n    const clonedAdditionalProperties = IsSchema(options.additionalProperties) ? { additionalProperties: CloneType(options.additionalProperties) } : {};\n    const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: CloneType(properties[key]) }), {});\n    return (requiredKeys.length > 0\n        ? { ...options, ...clonedAdditionalProperties, [Kind]: 'Object', type: 'object', properties: clonedProperties, required: requiredKeys }\n        : { ...options, ...clonedAdditionalProperties, [Kind]: 'Object', type: 'object', properties: clonedProperties });\n}\n/** `[Json]` Creates an Object type */\nexport const Object = _Object;\n", "import { CloneType } from '../clone/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[JavaScript]` Creates a Promise type */\nexport function Promise(item, options = {}) {\n    return {\n        ...options,\n        [Kind]: 'Promise',\n        type: 'Promise',\n        item: CloneType(item),\n    };\n}\n", "import { ReadonlyKind } from '../symbols/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\nimport { Discard } from '../discard/index.mjs';\nimport { ReadonlyFromMappedResult } from './readonly-from-mapped-result.mjs';\nimport { IsMappedResult } from '../guard/type.mjs';\nfunction RemoveReadonly(schema) {\n    return Discard(CloneType(schema), [ReadonlyKind]);\n}\nfunction AddReadonly(schema) {\n    return { ...CloneType(schema), [ReadonlyKind]: 'Readonly' };\n}\n// prettier-ignore\nfunction ReadonlyWithFlag(schema, F) {\n    return (F === false\n        ? RemoveReadonly(schema)\n        : AddReadonly(schema));\n}\n/** `[Json]` Creates a Readonly property */\nexport function Readonly(schema, enable) {\n    const F = enable ?? true;\n    return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);\n}\n", "import { MappedResult } from '../mapped/index.mjs';\nimport { Readonly } from './readonly.mjs';\n// prettier-ignore\nfunction FromProperties(K, F) {\n    return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {\n        return { ...Acc, [K2]: Readonly(K[K2], F) };\n    }, {});\n}\n// prettier-ignore\nfunction FromMappedResult(R, F) {\n    return FromProperties(R.properties, F);\n}\n// prettier-ignore\nexport function ReadonlyFromMappedResult(R, F) {\n    const P = FromMappedResult(R, F);\n    return MappedResult(P);\n}\n", "import { CloneRest } from '../clone/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a Tuple type */\nexport function Tuple(items, options = {}) {\n    // return TupleResolver.Resolve(T)\n    const [additionalItems, minItems, maxItems] = [false, items.length, items.length];\n    // prettier-ignore\n    return (items.length > 0 ?\n        { ...options, [Kind]: 'Tuple', type: 'array', items: CloneRest(items), additionalItems, minItems, maxItems } :\n        { ...options, [Kind]: 'Tuple', type: 'array', minItems, maxItems });\n}\n", "/** Returns true if element right is in the set of left */\n// prettier-ignore\nexport function SetIncludes(T, S) {\n    return T.includes(S);\n}\n/** Returns true if left is a subset of right */\nexport function SetIsSubset(T, S) {\n    return T.every((L) => SetIncludes(S, L));\n}\n/** Returns a distinct set of elements */\nexport function SetDistinct(T) {\n    return [...new Set(T)];\n}\n/** Returns the Intersect of the given sets */\nexport function SetIntersect(T, S) {\n    return T.filter((L) => S.includes(L));\n}\n/** Returns the Union of the given sets */\nexport function SetUnion(T, S) {\n    return [...T, ...S];\n}\n/** Returns the Complement by omitting elements in T that are in S */\n// prettier-ignore\nexport function SetComplement(T, S) {\n    return T.filter(L => !S.includes(L));\n}\n// prettier-ignore\nfunction SetIntersectManyResolve(T, Init) {\n    return T.reduce((Acc, L) => {\n        return SetIntersect(Acc, L);\n    }, Init);\n}\n// prettier-ignore\nexport function SetIntersectMany(T) {\n    return (T.length === 1\n        ? T[0]\n        // Use left to initialize the accumulator for resolve\n        : T.length > 1\n            ? SetIntersectManyResolve(T.slice(1), T[0])\n            : []);\n}\n/** Returns the Union of multiple sets */\nexport function SetUnionMany(T) {\n    return T.reduce((Acc, L) => [...Acc, ...L], []);\n}\n", "import { Kind, OptionalKind, ReadonlyKind } from '../symbols/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\nimport { Discard } from '../discard/index.mjs';\n// evaluation types\nimport { Array } from '../array/index.mjs';\nimport { AsyncIterator } from '../async-iterator/index.mjs';\nimport { Constructor } from '../constructor/index.mjs';\nimport { Function as FunctionType } from '../function/index.mjs';\nimport { IndexPropertyKeys } from '../indexed/index.mjs';\nimport { Intersect } from '../intersect/index.mjs';\nimport { Iterator } from '../iterator/index.mjs';\nimport { Literal } from '../literal/index.mjs';\nimport { Object } from '../object/index.mjs';\nimport { Optional } from '../optional/index.mjs';\nimport { Promise } from '../promise/index.mjs';\nimport { Readonly } from '../readonly/index.mjs';\nimport { Tuple } from '../tuple/index.mjs';\nimport { Union } from '../union/index.mjs';\n// operator\nimport { SetIncludes } from '../sets/index.mjs';\n// mapping types\nimport { MappedResult } from './mapped-result.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\n// prettier-ignore\nimport { IsArray, IsAsyncIterator, IsConstructor, IsFunction, IsIntersect, IsIterator, IsReadonly, IsMappedResult, IsMappedKey, IsObject, IsOptional, IsPromise, IsSchema, IsTuple, IsUnion, } from '../guard/type.mjs';\n// prettier-ignore\nfunction FromMappedResult(K, P) {\n    return (K in P\n        ? FromSchemaType(K, P[K])\n        : MappedResult(P));\n}\n// prettier-ignore\nfunction MappedKeyToKnownMappedResultProperties(K) {\n    return { [K]: Literal(K) };\n}\n// prettier-ignore\nfunction MappedKeyToUnknownMappedResultProperties(P) {\n    return P.reduce((Acc, L) => {\n        return { ...Acc, [L]: Literal(L) };\n    }, {});\n}\n// prettier-ignore\nfunction MappedKeyToMappedResultProperties(K, P) {\n    return (SetIncludes(P, K)\n        ? MappedKeyToKnownMappedResultProperties(K)\n        : MappedKeyToUnknownMappedResultProperties(P));\n}\n// prettier-ignore\nfunction FromMappedKey(K, P) {\n    const R = MappedKeyToMappedResultProperties(K, P);\n    return FromMappedResult(K, R);\n}\n// prettier-ignore\nfunction FromRest(K, T) {\n    return T.map(L => FromSchemaType(K, L));\n}\n// prettier-ignore\nfunction FromProperties(K, T) {\n    return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K2) => {\n        return { ...Acc, [K2]: FromSchemaType(K, T[K2]) };\n    }, {});\n}\n// prettier-ignore\nfunction FromSchemaType(K, T) {\n    return (\n    // unevaluated modifier types\n    IsOptional(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) :\n        IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) :\n            // unevaluated mapped types\n            IsMappedResult(T) ? FromMappedResult(K, T.properties) :\n                IsMappedKey(T) ? FromMappedKey(K, T.keys) :\n                    // unevaluated types\n                    IsConstructor(T) ? Constructor(FromRest(K, T.parameters), FromSchemaType(K, T.returns)) :\n                        IsFunction(T) ? FunctionType(FromRest(K, T.parameters), FromSchemaType(K, T.returns)) :\n                            IsAsyncIterator(T) ? AsyncIterator(FromSchemaType(K, T.items)) :\n                                IsIterator(T) ? Iterator(FromSchemaType(K, T.items)) :\n                                    IsIntersect(T) ? Intersect(FromRest(K, T.allOf)) :\n                                        IsUnion(T) ? Union(FromRest(K, T.anyOf)) :\n                                            IsTuple(T) ? Tuple(FromRest(K, T.items ?? [])) :\n                                                IsObject(T) ? Object(FromProperties(K, T.properties)) :\n                                                    IsArray(T) ? Array(FromSchemaType(K, T.items)) :\n                                                        IsPromise(T) ? Promise(FromSchemaType(K, T.item)) :\n                                                            T);\n}\n// prettier-ignore\nexport function MappedFunctionReturnType(K, T, Acc = {}) {\n    return K.reduce((Acc, L) => {\n        return { ...Acc, [L]: FromSchemaType(L, T) };\n    }, {});\n}\n/** `[Json]` Creates a Mapped object type */\nexport function Mapped(key, map, options = {}) {\n    const K = IsSchema(key) ? IndexPropertyKeys(key) : key;\n    const RT = map({ [Kind]: 'MappedKey', keys: K });\n    const R = MappedFunctionReturnType(K, RT);\n    return CloneType(Object(R), options);\n}\n", "import { MappedResult } from '../mapped/index.mjs';\nimport { Optional } from './optional.mjs';\n// prettier-ignore\nfunction FromProperties(P, F) {\n    return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {\n        return { ...Acc, [K2]: Optional(P[K2], F) };\n    }, {});\n}\n// prettier-ignore\nfunction FromMappedResult(R, F) {\n    return FromProperties(R.properties, F);\n}\n// prettier-ignore\nexport function OptionalFromMappedResult(R, F) {\n    const P = FromMappedResult(R, F);\n    return MappedResult(P);\n}\n", "import { OptionalKind } from '../symbols/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\nimport { Discard } from '../discard/index.mjs';\nimport { OptionalFromMappedResult } from './optional-from-mapped-result.mjs';\nimport { IsMappedResult } from '../guard/type.mjs';\nfunction RemoveOptional(schema) {\n    return Discard(CloneType(schema), [OptionalKind]);\n}\nfunction AddOptional(schema) {\n    return { ...CloneType(schema), [OptionalKind]: 'Optional' };\n}\n// prettier-ignore\nfunction OptionalWithFlag(schema, F) {\n    return (F === false\n        ? RemoveOptional(schema)\n        : AddOptional(schema));\n}\n/** `[Json]` Creates a Optional property */\nexport function Optional(schema, enable) {\n    const F = enable ?? true;\n    return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);\n}\n", "import { SetUnionMany, SetIntersectMany } from '../sets/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsIntersect, IsUnion, IsTuple, IsArray, IsObject, IsRecord } from '../guard/type.mjs';\n// prettier-ignore\nfunction FromRest(T) {\n    return T.reduce((Acc, L) => {\n        return [...Acc, KeyOfPropertyKeys(L)];\n    }, []);\n}\n// prettier-ignore\nfunction FromIntersect(T) {\n    const C = FromRest(T);\n    const R = SetUnionMany(C);\n    return R;\n}\n// prettier-ignore\nfunction FromUnion(T) {\n    const C = FromRest(T);\n    const R = SetIntersectMany(C);\n    return R;\n}\n// prettier-ignore\nfunction FromTuple(T) {\n    return T.map((_, I) => I.toString());\n}\n// prettier-ignore\nfunction FromArray(_) {\n    return (['[number]']);\n}\n// prettier-ignore\nfunction FromProperties(T) {\n    return (globalThis.Object.getOwnPropertyNames(T));\n}\n// ------------------------------------------------------------------\n// FromPatternProperties\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromPatternProperties(patternProperties) {\n    if (!includePatternProperties)\n        return [];\n    const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);\n    return patternPropertyKeys.map(key => {\n        return (key[0] === '^' && key[key.length - 1] === '$')\n            ? key.slice(1, key.length - 1)\n            : key;\n    });\n}\n/** Returns a tuple of PropertyKeys derived from the given TSchema. */\n// prettier-ignore\nexport function KeyOfPropertyKeys(T) {\n    return (IsIntersect(T) ? FromIntersect(T.allOf) :\n        IsUnion(T) ? FromUnion(T.anyOf) :\n            IsTuple(T) ? FromTuple(T.items ?? []) :\n                IsArray(T) ? FromArray(T.items) :\n                    IsObject(T) ? FromProperties(T.properties) :\n                        IsRecord(T) ? FromPatternProperties(T.patternProperties) :\n                            []);\n}\n// ----------------------------------------------------------------\n// KeyOfPattern\n// ----------------------------------------------------------------\nlet includePatternProperties = false;\n/** Returns a regular expression pattern derived from the given TSchema */\nexport function KeyOfPattern(schema) {\n    includePatternProperties = true;\n    const keys = KeyOfPropertyKeys(schema);\n    includePatternProperties = false;\n    const pattern = keys.map((key) => `(${key})`);\n    return `^(${pattern.join('|')})$`;\n}\n", "import { MappedResult } from '../mapped/index.mjs';\nimport { KeyOf } from './keyof.mjs';\n// prettier-ignore\nfunction FromProperties(K, options) {\n    return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {\n        return { ...Acc, [K2]: KeyOf(K[K2], options) };\n    }, {});\n}\n// prettier-ignore\nfunction FromMappedResult(R, options) {\n    return FromProperties(R.properties, options);\n}\n// prettier-ignore\nexport function KeyOfFromMappedResult(R, options) {\n    const P = FromMappedResult(R, options);\n    return MappedResult(P);\n}\n", "import { Literal } from '../literal/index.mjs';\nimport { Number } from '../number/index.mjs';\nimport { KeyOfPropertyKeys } from './keyof-property-keys.mjs';\nimport { UnionEvaluated } from '../union/index.mjs';\nimport { CloneType } from '../clone/type.mjs';\nimport { KeyOfFromMappedResult } from './keyof-from-mapped-result.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsMappedResult } from '../guard/type.mjs';\n// prettier-ignore\nexport function KeyOfPropertyKeysToRest(T) {\n    return T.map(L => L === '[number]' ? Number() : Literal(L));\n}\n/** `[Json]` Creates a KeyOf type */\nexport function KeyOf(T, options = {}) {\n    if (IsMappedResult(T)) {\n        return KeyOfFromMappedResult(T, options);\n    }\n    else {\n        const K = KeyOfPropertyKeys(T);\n        const S = KeyOfPropertyKeysToRest(K);\n        const U = UnionEvaluated(S);\n        return CloneType(U, options);\n    }\n}\n", "import { Kind } from '../symbols/index.mjs';\n/** Fast undefined check used for properties of type undefined */\nfunction Intersect(schema) {\n    return schema.allOf.every((schema) => ExtendsUndefinedCheck(schema));\n}\nfunction Union(schema) {\n    return schema.anyOf.some((schema) => ExtendsUndefinedCheck(schema));\n}\nfunction Not(schema) {\n    return !ExtendsUndefinedCheck(schema.not);\n}\n/** Fast undefined check used for properties of type undefined */\n// prettier-ignore\nexport function ExtendsUndefinedCheck(schema) {\n    return (schema[Kind] === 'Intersect' ? Intersect(schema) :\n        schema[Kind] === 'Union' ? Union(schema) :\n            schema[Kind] === 'Not' ? Not(schema) :\n                schema[Kind] === 'Undefined' ? true :\n                    false);\n}\n", "import { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates an Any type */\nexport function Any(options = {}) {\n    return { ...options, [Kind]: 'Any' };\n}\n", "import { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates an Unknown type */\nexport function Unknown(options = {}) {\n    return {\n        ...options,\n        [Kind]: 'Unknown',\n    };\n}\n", "import { Any } from '../any/index.mjs';\nimport { Function as FunctionType } from '../function/index.mjs';\nimport { Number } from '../number/index.mjs';\nimport { String } from '../string/index.mjs';\nimport { Unknown } from '../unknown/index.mjs';\nimport { TemplateLiteralToUnion } from '../template-literal/index.mjs';\nimport { PatternNumberExact, PatternStringExact } from '../patterns/index.mjs';\nimport { Kind, Hint } from '../symbols/index.mjs';\nimport { TypeBoxError } from '../error/index.mjs';\nimport { TypeGuard, ValueGuard } from '../guard/index.mjs';\nexport class ExtendsResolverError extends TypeBoxError {\n}\nexport var ExtendsResult;\n(function (ExtendsResult) {\n    ExtendsResult[ExtendsResult[\"Union\"] = 0] = \"Union\";\n    ExtendsResult[ExtendsResult[\"True\"] = 1] = \"True\";\n    ExtendsResult[ExtendsResult[\"False\"] = 2] = \"False\";\n})(ExtendsResult || (ExtendsResult = {}));\n// ------------------------------------------------------------------\n// IntoBooleanResult\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction IntoBooleanResult(result) {\n    return result === ExtendsResult.False ? result : ExtendsResult.True;\n}\n// ------------------------------------------------------------------\n// Throw\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction Throw(message) {\n    throw new ExtendsResolverError(message);\n}\n// ------------------------------------------------------------------\n// StructuralRight\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction IsStructuralRight(right) {\n    return (TypeGuard.IsNever(right) ||\n        TypeGuard.IsIntersect(right) ||\n        TypeGuard.IsUnion(right) ||\n        TypeGuard.IsUnknown(right) ||\n        TypeGuard.IsAny(right));\n}\n// prettier-ignore\nfunction StructuralRight(left, right) {\n    return (TypeGuard.IsNever(right) ? FromNeverRight(left, right) :\n        TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) :\n            TypeGuard.IsUnion(right) ? FromUnionRight(left, right) :\n                TypeGuard.IsUnknown(right) ? FromUnknownRight(left, right) :\n                    TypeGuard.IsAny(right) ? FromAnyRight(left, right) :\n                        Throw('StructuralRight'));\n}\n// ------------------------------------------------------------------\n// Any\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromAnyRight(left, right) {\n    return ExtendsResult.True;\n}\n// prettier-ignore\nfunction FromAny(left, right) {\n    return (TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) :\n        (TypeGuard.IsUnion(right) && right.anyOf.some((schema) => TypeGuard.IsAny(schema) || TypeGuard.IsUnknown(schema))) ? ExtendsResult.True :\n            TypeGuard.IsUnion(right) ? ExtendsResult.Union :\n                TypeGuard.IsUnknown(right) ? ExtendsResult.True :\n                    TypeGuard.IsAny(right) ? ExtendsResult.True :\n                        ExtendsResult.Union);\n}\n// ------------------------------------------------------------------\n// Array\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromArrayRight(left, right) {\n    return (TypeGuard.IsUnknown(left) ? ExtendsResult.False :\n        TypeGuard.IsAny(left) ? ExtendsResult.Union :\n            TypeGuard.IsNever(left) ? ExtendsResult.True :\n                ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromArray(left, right) {\n    return (TypeGuard.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True :\n        IsStructuralRight(right) ? StructuralRight(left, right) :\n            !TypeGuard.IsArray(right) ? ExtendsResult.False :\n                IntoBooleanResult(Visit(left.items, right.items)));\n}\n// ------------------------------------------------------------------\n// AsyncIterator\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromAsyncIterator(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        !TypeGuard.IsAsyncIterator(right) ? ExtendsResult.False :\n            IntoBooleanResult(Visit(left.items, right.items)));\n}\n// ------------------------------------------------------------------\n// BigInt\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromBigInt(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsBigInt(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Boolean\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromBooleanRight(left, right) {\n    return (TypeGuard.IsLiteralBoolean(left) ? ExtendsResult.True :\n        TypeGuard.IsBoolean(left) ? ExtendsResult.True :\n            ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromBoolean(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsBoolean(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Constructor\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromConstructor(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            !TypeGuard.IsConstructor(right) ? ExtendsResult.False :\n                left.parameters.length > right.parameters.length ? ExtendsResult.False :\n                    (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === ExtendsResult.True)) ? ExtendsResult.False :\n                        IntoBooleanResult(Visit(left.returns, right.returns)));\n}\n// ------------------------------------------------------------------\n// Date\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromDate(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsDate(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Function\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromFunction(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            !TypeGuard.IsFunction(right) ? ExtendsResult.False :\n                left.parameters.length > right.parameters.length ? ExtendsResult.False :\n                    (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === ExtendsResult.True)) ? ExtendsResult.False :\n                        IntoBooleanResult(Visit(left.returns, right.returns)));\n}\n// ------------------------------------------------------------------\n// Integer\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromIntegerRight(left, right) {\n    return (TypeGuard.IsLiteral(left) && ValueGuard.IsNumber(left.const) ? ExtendsResult.True :\n        TypeGuard.IsNumber(left) || TypeGuard.IsInteger(left) ? ExtendsResult.True :\n            ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromInteger(left, right) {\n    return (TypeGuard.IsInteger(right) || TypeGuard.IsNumber(right) ? ExtendsResult.True :\n        IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n                TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Intersect\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromIntersectRight(left, right) {\n    return right.allOf.every((schema) => Visit(left, schema) === ExtendsResult.True)\n        ? ExtendsResult.True\n        : ExtendsResult.False;\n}\n// prettier-ignore\nfunction FromIntersect(left, right) {\n    return left.allOf.some((schema) => Visit(schema, right) === ExtendsResult.True)\n        ? ExtendsResult.True\n        : ExtendsResult.False;\n}\n// ------------------------------------------------------------------\n// Iterator\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromIterator(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        !TypeGuard.IsIterator(right) ? ExtendsResult.False :\n            IntoBooleanResult(Visit(left.items, right.items)));\n}\n// ------------------------------------------------------------------\n// Literal\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromLiteral(left, right) {\n    return (TypeGuard.IsLiteral(right) && right.const === left.const ? ExtendsResult.True :\n        IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n                TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                    TypeGuard.IsString(right) ? FromStringRight(left, right) :\n                        TypeGuard.IsNumber(right) ? FromNumberRight(left, right) :\n                            TypeGuard.IsInteger(right) ? FromIntegerRight(left, right) :\n                                TypeGuard.IsBoolean(right) ? FromBooleanRight(left, right) :\n                                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Never\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromNeverRight(left, right) {\n    return ExtendsResult.False;\n}\n// prettier-ignore\nfunction FromNever(left, right) {\n    return ExtendsResult.True;\n}\n// ------------------------------------------------------------------\n// Not\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction UnwrapTNot(schema) {\n    let [current, depth] = [schema, 0];\n    while (true) {\n        if (!TypeGuard.IsNot(current))\n            break;\n        current = current.not;\n        depth += 1;\n    }\n    return depth % 2 === 0 ? current : Unknown();\n}\n// prettier-ignore\nfunction FromNot(left, right) {\n    // TypeScript has no concept of negated types, and attempts to correctly check the negated\n    // type at runtime would put TypeBox at odds with TypeScripts ability to statically infer\n    // the type. Instead we unwrap to either unknown or T and continue evaluating.\n    // prettier-ignore\n    return (TypeGuard.IsNot(left) ? Visit(UnwrapTNot(left), right) :\n        TypeGuard.IsNot(right) ? Visit(left, UnwrapTNot(right)) :\n            Throw('Invalid fallthrough for Not'));\n}\n// ------------------------------------------------------------------\n// Null\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromNull(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsNull(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Number\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromNumberRight(left, right) {\n    return (TypeGuard.IsLiteralNumber(left) ? ExtendsResult.True :\n        TypeGuard.IsNumber(left) || TypeGuard.IsInteger(left) ? ExtendsResult.True :\n            ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromNumber(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsInteger(right) || TypeGuard.IsNumber(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Object\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction IsObjectPropertyCount(schema, count) {\n    return Object.getOwnPropertyNames(schema.properties).length === count;\n}\n// prettier-ignore\nfunction IsObjectStringLike(schema) {\n    return IsObjectArrayLike(schema);\n}\n// prettier-ignore\nfunction IsObjectSymbolLike(schema) {\n    return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'description' in schema.properties && TypeGuard.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && ((TypeGuard.IsString(schema.properties.description.anyOf[0]) &&\n        TypeGuard.IsUndefined(schema.properties.description.anyOf[1])) || (TypeGuard.IsString(schema.properties.description.anyOf[1]) &&\n        TypeGuard.IsUndefined(schema.properties.description.anyOf[0]))));\n}\n// prettier-ignore\nfunction IsObjectNumberLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n}\n// prettier-ignore\nfunction IsObjectBooleanLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n}\n// prettier-ignore\nfunction IsObjectBigIntLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n}\n// prettier-ignore\nfunction IsObjectDateLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n}\n// prettier-ignore\nfunction IsObjectUint8ArrayLike(schema) {\n    return IsObjectArrayLike(schema);\n}\n// prettier-ignore\nfunction IsObjectFunctionLike(schema) {\n    const length = Number();\n    return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === ExtendsResult.True);\n}\n// prettier-ignore\nfunction IsObjectConstructorLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n}\n// prettier-ignore\nfunction IsObjectArrayLike(schema) {\n    const length = Number();\n    return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === ExtendsResult.True);\n}\n// prettier-ignore\nfunction IsObjectPromiseLike(schema) {\n    const then = FunctionType([Any()], Any());\n    return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'then' in schema.properties && IntoBooleanResult(Visit(schema.properties['then'], then)) === ExtendsResult.True);\n}\n// ------------------------------------------------------------------\n// Property\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction Property(left, right) {\n    return (Visit(left, right) === ExtendsResult.False ? ExtendsResult.False :\n        TypeGuard.IsOptional(left) && !TypeGuard.IsOptional(right) ? ExtendsResult.False :\n            ExtendsResult.True);\n}\n// prettier-ignore\nfunction FromObjectRight(left, right) {\n    return (TypeGuard.IsUnknown(left) ? ExtendsResult.False :\n        TypeGuard.IsAny(left) ? ExtendsResult.Union : (TypeGuard.IsNever(left) ||\n            (TypeGuard.IsLiteralString(left) && IsObjectStringLike(right)) ||\n            (TypeGuard.IsLiteralNumber(left) && IsObjectNumberLike(right)) ||\n            (TypeGuard.IsLiteralBoolean(left) && IsObjectBooleanLike(right)) ||\n            (TypeGuard.IsSymbol(left) && IsObjectSymbolLike(right)) ||\n            (TypeGuard.IsBigInt(left) && IsObjectBigIntLike(right)) ||\n            (TypeGuard.IsString(left) && IsObjectStringLike(right)) ||\n            (TypeGuard.IsSymbol(left) && IsObjectSymbolLike(right)) ||\n            (TypeGuard.IsNumber(left) && IsObjectNumberLike(right)) ||\n            (TypeGuard.IsInteger(left) && IsObjectNumberLike(right)) ||\n            (TypeGuard.IsBoolean(left) && IsObjectBooleanLike(right)) ||\n            (TypeGuard.IsUint8Array(left) && IsObjectUint8ArrayLike(right)) ||\n            (TypeGuard.IsDate(left) && IsObjectDateLike(right)) ||\n            (TypeGuard.IsConstructor(left) && IsObjectConstructorLike(right)) ||\n            (TypeGuard.IsFunction(left) && IsObjectFunctionLike(right))) ? ExtendsResult.True :\n            (TypeGuard.IsRecord(left) && TypeGuard.IsString(RecordKey(left))) ? (() => {\n                // When expressing a Record with literal key values, the Record is converted into a Object with\n                // the Hint assigned as `Record`. This is used to invert the extends logic.\n                return right[Hint] === 'Record' ? ExtendsResult.True : ExtendsResult.False;\n            })() :\n                (TypeGuard.IsRecord(left) && TypeGuard.IsNumber(RecordKey(left))) ? (() => {\n                    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;\n                })() :\n                    ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromObject(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n            !TypeGuard.IsObject(right) ? ExtendsResult.False :\n                (() => {\n                    for (const key of Object.getOwnPropertyNames(right.properties)) {\n                        if (!(key in left.properties) && !TypeGuard.IsOptional(right.properties[key])) {\n                            return ExtendsResult.False;\n                        }\n                        if (TypeGuard.IsOptional(right.properties[key])) {\n                            return ExtendsResult.True;\n                        }\n                        if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {\n                            return ExtendsResult.False;\n                        }\n                    }\n                    return ExtendsResult.True;\n                })());\n}\n// ------------------------------------------------------------------\n// Promise\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromPromise(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True :\n            !TypeGuard.IsPromise(right) ? ExtendsResult.False :\n                IntoBooleanResult(Visit(left.item, right.item)));\n}\n// ------------------------------------------------------------------\n// Record\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction RecordKey(schema) {\n    return (PatternNumberExact in schema.patternProperties ? Number() :\n        PatternStringExact in schema.patternProperties ? String() :\n            Throw('Unknown record key pattern'));\n}\n// prettier-ignore\nfunction RecordValue(schema) {\n    return (PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] :\n        PatternStringExact in schema.patternProperties ? schema.patternProperties[PatternStringExact] :\n            Throw('Unable to get record value schema'));\n}\n// prettier-ignore\nfunction FromRecordRight(left, right) {\n    const [Key, Value] = [RecordKey(right), RecordValue(right)];\n    return ((TypeGuard.IsLiteralString(left) && TypeGuard.IsNumber(Key) && IntoBooleanResult(Visit(left, Value)) === ExtendsResult.True) ? ExtendsResult.True :\n        TypeGuard.IsUint8Array(left) && TypeGuard.IsNumber(Key) ? Visit(left, Value) :\n            TypeGuard.IsString(left) && TypeGuard.IsNumber(Key) ? Visit(left, Value) :\n                TypeGuard.IsArray(left) && TypeGuard.IsNumber(Key) ? Visit(left, Value) :\n                    TypeGuard.IsObject(left) ? (() => {\n                        for (const key of Object.getOwnPropertyNames(left.properties)) {\n                            if (Property(Value, left.properties[key]) === ExtendsResult.False) {\n                                return ExtendsResult.False;\n                            }\n                        }\n                        return ExtendsResult.True;\n                    })() :\n                        ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromRecord(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            !TypeGuard.IsRecord(right) ? ExtendsResult.False :\n                Visit(RecordValue(left), RecordValue(right)));\n}\n// ------------------------------------------------------------------\n// RegExp\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromRegExp(left, right) {\n    // Note: RegExp types evaluate as strings, not RegExp objects.\n    // Here we remap either into string and continue evaluating.\n    const L = TypeGuard.IsRegExp(left) ? String() : left;\n    const R = TypeGuard.IsRegExp(right) ? String() : right;\n    return Visit(L, R);\n}\n// ------------------------------------------------------------------\n// String\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromStringRight(left, right) {\n    return (TypeGuard.IsLiteral(left) && ValueGuard.IsString(left.const) ? ExtendsResult.True :\n        TypeGuard.IsString(left) ? ExtendsResult.True :\n            ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromString(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsString(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Symbol\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromSymbol(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsSymbol(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// TemplateLiteral\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromTemplateLiteral(left, right) {\n    // TemplateLiteral types are resolved to either unions for finite expressions or string\n    // for infinite expressions. Here we call to TemplateLiteralResolver to resolve for\n    // either type and continue evaluating.\n    return (TypeGuard.IsTemplateLiteral(left) ? Visit(TemplateLiteralToUnion(left), right) :\n        TypeGuard.IsTemplateLiteral(right) ? Visit(left, TemplateLiteralToUnion(right)) :\n            Throw('Invalid fallthrough for TemplateLiteral'));\n}\n// ------------------------------------------------------------------\n// Tuple\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction IsArrayOfTuple(left, right) {\n    return (TypeGuard.IsArray(right) &&\n        left.items !== undefined &&\n        left.items.every((schema) => Visit(schema, right.items) === ExtendsResult.True));\n}\n// prettier-ignore\nfunction FromTupleRight(left, right) {\n    return (TypeGuard.IsNever(left) ? ExtendsResult.True :\n        TypeGuard.IsUnknown(left) ? ExtendsResult.False :\n            TypeGuard.IsAny(left) ? ExtendsResult.Union :\n                ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromTuple(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True :\n            TypeGuard.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True :\n                !TypeGuard.IsTuple(right) ? ExtendsResult.False :\n                    (ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items)) || (!ValueGuard.IsUndefined(left.items) && ValueGuard.IsUndefined(right.items)) ? ExtendsResult.False :\n                        (ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items)) ? ExtendsResult.True :\n                            left.items.every((schema, index) => Visit(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True :\n                                ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Uint8Array\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromUint8Array(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsUint8Array(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Undefined\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromUndefined(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsVoid(right) ? FromVoidRight(left, right) :\n                    TypeGuard.IsUndefined(right) ? ExtendsResult.True :\n                        ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Union\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromUnionRight(left, right) {\n    return right.anyOf.some((schema) => Visit(left, schema) === ExtendsResult.True)\n        ? ExtendsResult.True\n        : ExtendsResult.False;\n}\n// prettier-ignore\nfunction FromUnion(left, right) {\n    return left.anyOf.every((schema) => Visit(schema, right) === ExtendsResult.True)\n        ? ExtendsResult.True\n        : ExtendsResult.False;\n}\n// ------------------------------------------------------------------\n// Unknown\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromUnknownRight(left, right) {\n    return ExtendsResult.True;\n}\n// prettier-ignore\nfunction FromUnknown(left, right) {\n    return (TypeGuard.IsNever(right) ? FromNeverRight(left, right) :\n        TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) :\n            TypeGuard.IsUnion(right) ? FromUnionRight(left, right) :\n                TypeGuard.IsAny(right) ? FromAnyRight(left, right) :\n                    TypeGuard.IsString(right) ? FromStringRight(left, right) :\n                        TypeGuard.IsNumber(right) ? FromNumberRight(left, right) :\n                            TypeGuard.IsInteger(right) ? FromIntegerRight(left, right) :\n                                TypeGuard.IsBoolean(right) ? FromBooleanRight(left, right) :\n                                    TypeGuard.IsArray(right) ? FromArrayRight(left, right) :\n                                        TypeGuard.IsTuple(right) ? FromTupleRight(left, right) :\n                                            TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n                                                TypeGuard.IsUnknown(right) ? ExtendsResult.True :\n                                                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Void\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromVoidRight(left, right) {\n    return (TypeGuard.IsUndefined(left) ? ExtendsResult.True :\n        TypeGuard.IsUndefined(left) ? ExtendsResult.True :\n            ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromVoid(left, right) {\n    return (TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) :\n        TypeGuard.IsUnion(right) ? FromUnionRight(left, right) :\n            TypeGuard.IsUnknown(right) ? FromUnknownRight(left, right) :\n                TypeGuard.IsAny(right) ? FromAnyRight(left, right) :\n                    TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n                        TypeGuard.IsVoid(right) ? ExtendsResult.True :\n                            ExtendsResult.False);\n}\n// prettier-ignore\nfunction Visit(left, right) {\n    return (\n    // resolvable\n    (TypeGuard.IsTemplateLiteral(left) || TypeGuard.IsTemplateLiteral(right)) ? FromTemplateLiteral(left, right) :\n        (TypeGuard.IsRegExp(left) || TypeGuard.IsRegExp(right)) ? FromRegExp(left, right) :\n            (TypeGuard.IsNot(left) || TypeGuard.IsNot(right)) ? FromNot(left, right) :\n                // standard\n                TypeGuard.IsAny(left) ? FromAny(left, right) :\n                    TypeGuard.IsArray(left) ? FromArray(left, right) :\n                        TypeGuard.IsBigInt(left) ? FromBigInt(left, right) :\n                            TypeGuard.IsBoolean(left) ? FromBoolean(left, right) :\n                                TypeGuard.IsAsyncIterator(left) ? FromAsyncIterator(left, right) :\n                                    TypeGuard.IsConstructor(left) ? FromConstructor(left, right) :\n                                        TypeGuard.IsDate(left) ? FromDate(left, right) :\n                                            TypeGuard.IsFunction(left) ? FromFunction(left, right) :\n                                                TypeGuard.IsInteger(left) ? FromInteger(left, right) :\n                                                    TypeGuard.IsIntersect(left) ? FromIntersect(left, right) :\n                                                        TypeGuard.IsIterator(left) ? FromIterator(left, right) :\n                                                            TypeGuard.IsLiteral(left) ? FromLiteral(left, right) :\n                                                                TypeGuard.IsNever(left) ? FromNever(left, right) :\n                                                                    TypeGuard.IsNull(left) ? FromNull(left, right) :\n                                                                        TypeGuard.IsNumber(left) ? FromNumber(left, right) :\n                                                                            TypeGuard.IsObject(left) ? FromObject(left, right) :\n                                                                                TypeGuard.IsRecord(left) ? FromRecord(left, right) :\n                                                                                    TypeGuard.IsString(left) ? FromString(left, right) :\n                                                                                        TypeGuard.IsSymbol(left) ? FromSymbol(left, right) :\n                                                                                            TypeGuard.IsTuple(left) ? FromTuple(left, right) :\n                                                                                                TypeGuard.IsPromise(left) ? FromPromise(left, right) :\n                                                                                                    TypeGuard.IsUint8Array(left) ? FromUint8Array(left, right) :\n                                                                                                        TypeGuard.IsUndefined(left) ? FromUndefined(left, right) :\n                                                                                                            TypeGuard.IsUnion(left) ? FromUnion(left, right) :\n                                                                                                                TypeGuard.IsUnknown(left) ? FromUnknown(left, right) :\n                                                                                                                    TypeGuard.IsVoid(left) ? FromVoid(left, right) :\n                                                                                                                        Throw(`Unknown left type operand '${left[Kind]}'`));\n}\nexport function ExtendsCheck(left, right) {\n    return Visit(left, right);\n}\n", "import { MappedResult } from '../mapped/index.mjs';\nimport { Literal } from '../literal/index.mjs';\nimport { Extends } from './extends.mjs';\n// prettier-ignore\nfunction FromPropertyKey(K, U, L, R, options) {\n    return {\n        [K]: Extends(Literal(K), U, L, R, options)\n    };\n}\n// prettier-ignore\nfunction FromPropertyKeys(K, U, L, R, options) {\n    return K.reduce((Acc, LK) => {\n        return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };\n    }, {});\n}\n// prettier-ignore\nfunction FromMappedKey(K, U, L, R, options) {\n    return FromPropertyKeys(K.keys, U, L, R, options);\n}\n// prettier-ignore\nexport function ExtendsFromMappedKey(T, U, L, R, options) {\n    const P = FromMappedKey(T, U, L, R, options);\n    return MappedResult(P);\n}\n", "import { Union } from '../union/index.mjs';\nimport { ExtendsCheck, ExtendsResult } from './extends-check.mjs';\nimport { CloneType } from '../clone/type.mjs';\nimport { ExtendsFromMappedKey } from './extends-from-mapped-key.mjs';\nimport { ExtendsFromMappedResult } from './extends-from-mapped-result.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsMappedKey, IsMappedResult } from '../guard/type.mjs';\n// prettier-ignore\nfunction ExtendsResolve(left, right, trueType, falseType) {\n    const R = ExtendsCheck(left, right);\n    return (R === ExtendsResult.Union ? Union([trueType, falseType]) :\n        R === ExtendsResult.True ? trueType :\n            falseType);\n}\n/** `[Json]` Creates a Conditional type */\nexport function Extends(L, R, T, F, options = {}) {\n    // prettier-ignore\n    return (IsMappedResult(L) ? ExtendsFromMappedResult(L, R, T, F, options) :\n        IsMappedKey(L) ? CloneType(ExtendsFromMappedKey(L, R, T, F, options)) :\n            CloneType(ExtendsResolve(L, R, T, F), options));\n}\n", "import { MappedResult } from '../mapped/index.mjs';\nimport { Extends } from './extends.mjs';\n// prettier-ignore\nfunction FromProperties(P, Right, True, False, options) {\n    return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {\n        return { ...Acc, [K2]: Extends(P[K2], Right, True, False, options) };\n    }, {});\n}\n// prettier-ignore\nfunction FromMappedResult(Left, Right, True, False, options) {\n    return FromProperties(Left.properties, Right, True, False, options);\n}\n// prettier-ignore\nexport function ExtendsFromMappedResult(Left, Right, True, False, options) {\n    const P = FromMappedResult(Left, Right, True, False, options);\n    return MappedResult(P);\n}\n"],
  "mappings": "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",
  "names": ["Set", "Clear", "Delete", "Entries", "Get", "Has", "Set", "map", "value", "Array", "type_exports", "IsArray", "IsAsyncIterator", "IsBigInt", "IsBoolean", "IsDate", "IsFunction", "IsIterator", "IsNull", "IsNumber", "IsObject", "IsRegExp", "IsString", "IsSymbol", "IsUint8Array", "IsUndefined", "IsArray", "IsAsyncIterator", "IsBigInt", "IsBoolean", "IsDate", "IsFunction", "IsIterator", "IsNull", "IsNumber", "IsObject", "IsRegExp", "IsString", "IsSymbol", "IsUndefined", "IsUint8Array", "IsObject", "RemoveOptionalFromRest", "RemoveOptionalFromType", "range", "pattern", "Visit", "schema", "IsNumber", "IsBigInt", "IsString", "IsBoolean", "FromUnion", "IsNumber", "FromUnion", "IsArray", "IsObject", "Object", "Promise", "FromProperties", "FromMappedResult", "FromMappedResult", "FromRest", "FromProperties", "IsFunction", "IsAsyncIterator", "IsIterator", "IsObject", "Object", "IsArray", "Array", "Promise", "Acc", "map", "FromProperties", "FromMappedResult", "FromRest", "FromIntersect", "FromUnion", "FromTuple", "FromArray", "FromProperties", "IsArray", "IsObject", "FromProperties", "FromMappedResult", "Intersect", "schema", "Union", "ExtendsResult", "type_exports", "FromArray", "Visit", "FromIntersect", "FromLiteral", "FromTemplateLiteral", "FromTuple", "FromUnion", "FromMappedKey", "FromProperties", "FromMappedResult"]
}
