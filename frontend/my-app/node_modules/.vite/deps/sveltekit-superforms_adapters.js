import {
  createAdapter,
  createJsonSchema,
  splitPath,
  traversePath,
  traversePaths
} from "./chunk-3YYHEB6O.js";
import "./chunk-6RJHDZCZ.js";
import "./chunk-X7HCJ7ZS.js";
import {
  ZodFirstPartyTypeKind
} from "./chunk-WD5HYJAR.js";
import "./chunk-5EOG3U2A.js";
import "./chunk-ACDCLTWX.js";
import "./chunk-TDRWH72F.js";
import "./chunk-42EXQU3F.js";
import "./chunk-E5KDLRTM.js";
import "./chunk-XSLCAIPP.js";
import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-OSJZHPF7.js";

// node_modules/memoize-weak/lib/memoize.js
var require_memoize = __commonJS({
  "node_modules/memoize-weak/lib/memoize.js"(exports, module) {
    function isPrimitive(value) {
      return typeof value !== "object" && typeof value !== "function" || value === null;
    }
    function MapTree() {
      this.childBranches = /* @__PURE__ */ new WeakMap();
      this.primitiveKeys = /* @__PURE__ */ new Map();
      this.hasValue = false;
      this.value = void 0;
    }
    MapTree.prototype.has = function has(key) {
      var keyObject = isPrimitive(key) ? this.primitiveKeys.get(key) : key;
      return keyObject ? this.childBranches.has(keyObject) : false;
    };
    MapTree.prototype.get = function get(key) {
      var keyObject = isPrimitive(key) ? this.primitiveKeys.get(key) : key;
      return keyObject ? this.childBranches.get(keyObject) : void 0;
    };
    MapTree.prototype.resolveBranch = function resolveBranch(key) {
      if (this.has(key)) {
        return this.get(key);
      }
      var newBranch = new MapTree();
      var keyObject = this.createKey(key);
      this.childBranches.set(keyObject, newBranch);
      return newBranch;
    };
    MapTree.prototype.setValue = function setValue(value) {
      this.hasValue = true;
      return this.value = value;
    };
    MapTree.prototype.createKey = function createKey(key) {
      if (isPrimitive(key)) {
        var keyObject = {};
        this.primitiveKeys.set(key, keyObject);
        return keyObject;
      }
      return key;
    };
    MapTree.prototype.clear = function clear() {
      if (arguments.length === 0) {
        this.childBranches = /* @__PURE__ */ new WeakMap();
        this.primitiveKeys.clear();
        this.hasValue = false;
        this.value = void 0;
      } else if (arguments.length === 1) {
        var key = arguments[0];
        if (isPrimitive(key)) {
          var keyObject = this.primitiveKeys.get(key);
          if (keyObject) {
            this.childBranches.delete(keyObject);
            this.primitiveKeys.delete(key);
          }
        } else {
          this.childBranches.delete(key);
        }
      } else {
        var childKey = arguments[0];
        if (this.has(childKey)) {
          var childBranch = this.get(childKey);
          childBranch.clear.apply(childBranch, Array.prototype.slice.call(arguments, 1));
        }
      }
    };
    module.exports = function memoize2(fn) {
      var argsTree = new MapTree();
      function memoized() {
        var args = Array.prototype.slice.call(arguments);
        var argNode = args.reduce(function getBranch(parentBranch, arg) {
          return parentBranch.resolveBranch(arg);
        }, argsTree);
        if (argNode.hasValue) {
          return argNode.value;
        }
        var value = fn.apply(null, args);
        return argNode.setValue(value);
      }
      memoized.clear = argsTree.clear.bind(argsTree);
      return memoized;
    };
  }
});

// node_modules/memoize-weak/index.js
var require_memoize_weak = __commonJS({
  "node_modules/memoize-weak/index.js"(exports, module) {
    module.exports = require_memoize();
  }
});

// node_modules/sveltekit-superforms/dist/memoize.js
var import_memoize_weak = __toESM(require_memoize_weak(), 1);
var memoize = import_memoize_weak.default;

// node_modules/sveltekit-superforms/dist/adapters/arktype.js
async function validate(schema, data) {
  const result = schema(data);
  if (result.problems == null) {
    return {
      data: result.data,
      success: true
    };
  }
  return {
    issues: Array.from(result.problems).map(({ message, path }) => ({
      message,
      path
    })),
    success: false
  };
}
function _arktype(schema, options) {
  return createAdapter({
    superFormValidationLibrary: "arktype",
    defaults: options.defaults,
    jsonSchema: createJsonSchema(options),
    async validate(data) {
      const result = schema(data);
      if (result.problems == null) {
        return {
          data: result.data,
          success: true
        };
      }
      return {
        issues: Array.from(result.problems).map(({ message, path }) => ({
          message,
          path
        })),
        success: false
      };
    }
  });
}
function _arktypeClient(schema) {
  return {
    superFormValidationLibrary: "arktype",
    validate: async (data) => validate(schema, data)
  };
}
var arktype = memoize(_arktype);
var arktypeClient = memoize(_arktypeClient);

// node_modules/sveltekit-superforms/dist/adapters/joi-to-json-schema/index.js
function assert(condition, errorMessage) {
  if (!condition)
    throw new Error(errorMessage);
}
var TYPES = {
  alternatives: (schema, joi2, transformer) => {
    const result = schema.oneOf = [];
    joi2.matches.forEach(function(match) {
      if (match.schema) {
        return result.push(convert(match.schema, transformer));
      }
      if (!match.is) {
        throw new Error('joi.when requires an "is"');
      }
      if (!(match.then || match.otherwise)) {
        throw new Error('joi.when requires one or both of "then" and "otherwise"');
      }
      if (match.then) {
        result.push(convert(match.then, transformer));
      }
      if (match.otherwise) {
        result.push(convert(match.otherwise, transformer));
      }
    });
    return schema;
  },
  date: (schema) => {
    schema.type = "Date";
    return schema;
  },
  any: (schema) => {
    delete schema.type;
    return schema;
  },
  array: (schema, joi2, transformer) => {
    var _a;
    schema.type = "array";
    (_a = joi2._rules) == null ? void 0 : _a.forEach((test) => {
      switch (test.name) {
        case "unique":
          schema.uniqueItems = true;
          break;
        case "length":
          schema.minItems = schema.maxItems = test.args.limit;
          break;
        case "min":
          schema.minItems = test.args.limit;
          break;
        case "max":
          schema.maxItems = test.args.limit;
          break;
      }
    });
    if (joi2.$_terms) {
      let list;
      if (joi2.$_terms._inclusions.length) {
        list = joi2.$_terms._inclusions;
      } else if (joi2.$_terms._requireds.length) {
        list = joi2.$_terms._requireds;
      }
      if (list) {
        schema.items = convert(list[0], transformer);
      }
    }
    return schema;
  },
  binary: (schema, joi2) => {
    schema.type = "string";
    schema.contentMediaType = joi2._meta.length > 0 && joi2._meta[0].contentMediaType ? joi2._meta[0].contentMediaType : "text/plain";
    schema.contentEncoding = joi2._flags.encoding ? joi2._flags.encoding : "binary";
    return schema;
  },
  boolean: (schema) => {
    schema.type = "boolean";
    return schema;
  },
  number: (schema, joi2) => {
    var _a;
    schema.type = "number";
    (_a = joi2._rules) == null ? void 0 : _a.forEach((test) => {
      switch (test.name) {
        case "integer":
          schema.type = "integer";
          break;
        case "less":
          schema.exclusiveMaximum = test.args.limit;
          break;
        case "greater":
          schema.exclusiveMinimum = test.args.limit;
          break;
        case "min":
          schema.minimum = test.args.limit;
          break;
        case "max":
          schema.maximum = test.args.limit;
          break;
        case "precision": {
          let multipleOf;
          if (test.args.limit && test.args.limit > 1) {
            multipleOf = JSON.parse("0." + "0".repeat(test.args.limit - 1) + "1");
          } else {
            multipleOf = 1;
          }
          schema.multipleOf = multipleOf;
          break;
        }
      }
    });
    return schema;
  },
  string: (schema, joi2) => {
    schema.type = "string";
    joi2._rules.forEach((test) => {
      switch (test.name) {
        case "email":
          schema.format = "email";
          break;
        case "pattern":
        case "regex": {
          const arg = test.args;
          const pattern = arg && arg.regex ? arg.regex : arg;
          schema.pattern = String(pattern).replace(/^\//, "").replace(/\/$/, "");
          break;
        }
        case "min":
          schema.minLength = test.args.limit;
          break;
        case "max":
          schema.maxLength = test.args.limit;
          break;
        case "length":
          schema.minLength = schema.maxLength = test.args.limit;
          break;
        case "uri":
          schema.format = "uri";
          break;
      }
    });
    return schema;
  },
  object: (schema, joi2, transformer) => {
    var _a, _b;
    schema.type = "object";
    schema.properties = {};
    schema.additionalProperties = Boolean(joi2._flags.allowUnknown || !joi2._inner.children);
    schema.pattern = // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ((_a = joi2.patterns) == null ? void 0 : _a.map((pattern) => {
      return { regex: pattern.regex, rule: convert(pattern.rule, transformer) };
    })) ?? [];
    if (!((_b = joi2.$_terms.keys) == null ? void 0 : _b.length)) {
      return schema;
    }
    joi2.$_terms.keys.forEach((property) => {
      if (property.schema._flags.presence !== "forbidden") {
        if (!schema.properties)
          schema.properties = {};
        schema.properties[property.key] = convert(property.schema, transformer);
        if (property.schema._flags.presence === "required" || property.schema._settings && property.schema._settings.presence === "required" && property.schema._flags.presence !== "optional") {
          schema.required = schema.required || [];
          schema.required.push(property.key);
        }
      }
    });
    return schema;
  }
};
function convert(joi2, transformer) {
  var _a;
  assert("object" === typeof joi2 && "type" in joi2, "requires a joi schema object");
  if (!TYPES[joi2.type]) {
    throw new Error(`sorry, do not know how to convert unknown joi type: "${joi2.type}"`);
  }
  if (transformer) {
    assert("function" === typeof transformer, "transformer must be a function");
  }
  const schema = {};
  if (joi2._description) {
    schema.description = joi2._description;
  }
  if (joi2._examples && joi2._examples.length > 0) {
    schema.examples = joi2._examples.map((e) => e.value);
  }
  if (joi2._examples && joi2._examples.length === 1) {
    schema.examples = joi2._examples[0].value;
  }
  if (joi2._settings && joi2._settings.language && joi2._settings.language.label) {
    schema.title = joi2._settings.language.label;
  } else if (joi2._flags && joi2._flags.label) {
    schema.title = joi2._flags.label;
  }
  if (joi2._flags && joi2._flags.default !== void 0 && joi2._flags.default !== null) {
    schema["default"] = joi2._flags.default;
  }
  if (joi2._valids && joi2._valids._set && (joi2._valids._set.size || joi2._valids._set.length)) {
    if (Array.isArray(joi2.children) || !joi2._flags.allowOnly) {
      return {
        anyOf: [
          {
            type: joi2.type,
            enum: [...joi2._valids._set]
          },
          TYPES[joi2.type](schema, joi2, transformer)
        ]
      };
    }
    schema["enum"] = [...joi2._valids._set];
  }
  let result = TYPES[joi2.type](schema, joi2, transformer);
  if (transformer) {
    result = transformer(result, joi2);
  }
  if (((_a = joi2._valids) == null ? void 0 : _a._values) && joi2._valids._values.size && !joi2._flags.allowOnly) {
    const constants = Array.from(joi2._valids._values).map((v) => ({
      const: v
    }));
    if (result.anyOf) {
      result.anyOf = [...constants, ...result.anyOf];
    } else {
      result = { anyOf: [...constants, result] };
    }
  }
  return result;
}
convert.TYPES = TYPES;

// node_modules/sveltekit-superforms/dist/adapters/joi.js
async function validate2(schema, data) {
  const result = schema.validate(data, { abortEarly: false });
  if (result.error == null) {
    return {
      data: result.value,
      success: true
    };
  }
  return {
    issues: result.error.details.map(({ message, path }) => ({
      message,
      path
    })),
    success: false
  };
}
function _joi(schema, options) {
  return createAdapter({
    superFormValidationLibrary: "joi",
    jsonSchema: (options == null ? void 0 : options.jsonSchema) ?? convert(schema),
    defaults: options == null ? void 0 : options.defaults,
    validate: async (data) => validate2(schema, data)
  });
}
function _joiClient(schema) {
  return {
    superFormValidationLibrary: "joi",
    validate: async (data) => validate2(schema, data)
  };
}
var joi = memoize(_joi);
var joiClient = memoize(_joiClient);

// node_modules/sveltekit-superforms/dist/adapters/superform.js
function _superform(schema) {
  return {
    superFormValidationLibrary: "superform",
    async validate(data) {
      if (!data || typeof data !== "object")
        data = {};
      else
        data = { ...data };
      const newData = data;
      for (const [key, value] of Object.entries(schema)) {
        if (typeof value === "function" && !(key in newData)) {
          newData[key] = void 0;
        }
      }
      const output = [];
      function mapErrors(path, errors2) {
        if (!errors2)
          return;
        if (typeof errors2 === "string")
          errors2 = [errors2];
        errors2.forEach((message) => {
          output.push({
            path,
            message
          });
        });
      }
      const queue = [];
      traversePaths(newData, async ({ value, path }) => {
        const validationPath = path.filter((p) => /\D/.test(String(p)));
        const maybeValidator = traversePath(schema, validationPath);
        if (typeof (maybeValidator == null ? void 0 : maybeValidator.value) === "function") {
          const check = maybeValidator.value;
          queue.push({ path, errors: check(value) });
        }
      });
      const errors = await Promise.all(queue.map((check) => check.errors));
      for (let i = 0; i < errors.length; i++) {
        mapErrors(queue[i].path, errors[i]);
      }
      return output.length ? {
        success: false,
        issues: output
      } : {
        success: true,
        data
      };
    }
  };
}
var superformClient = memoize(_superform);

// node_modules/sveltekit-superforms/dist/adapters/typebox.js
var Email = /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i;
async function modules() {
  const { TypeCompiler } = await import(
    /* webpackIgnore: true */
    "./compiler-ZUIS7JBZ.js"
  );
  const { FormatRegistry } = await import(
    /* webpackIgnore: true */
    "./import-B734Z75O.js"
  );
  return { TypeCompiler, FormatRegistry };
}
var fetchModule = memoize(modules);
async function validate3(schema, data) {
  const { TypeCompiler, FormatRegistry } = await fetchModule();
  if (!compiled.has(schema)) {
    compiled.set(schema, TypeCompiler.Compile(schema));
  }
  if (!FormatRegistry.Has("email")) {
    FormatRegistry.Set("email", (value) => Email.test(value));
  }
  const validator = compiled.get(schema);
  const errors = [...(validator == null ? void 0 : validator.Errors(data)) ?? []];
  if (!errors.length) {
    return { success: true, data };
  }
  return {
    success: false,
    issues: errors.map((issue) => ({
      path: issue.path.substring(1).split("/"),
      message: issue.message
    }))
  };
}
function _typebox(schema) {
  return createAdapter({
    superFormValidationLibrary: "typebox",
    validate: async (data) => validate3(schema, data),
    jsonSchema: schema
  });
}
function _typeboxClient(schema) {
  return {
    superFormValidationLibrary: "typebox",
    validate: async (data) => validate3(schema, data)
  };
}
var typebox = memoize(_typebox);
var typeboxClient = memoize(_typeboxClient);
var compiled = /* @__PURE__ */ new WeakMap();

// node_modules/valibot/dist/index.js
var ValiError = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(issues) {
    super(issues[0].message);
    __publicField(this, "issues");
    this.name = "ValiError";
    this.issues = issues;
  }
};
var BrandSymbol = Symbol("brand");
var store;
function getGlobalConfig(config) {
  return {
    lang: (config == null ? void 0 : config.lang) ?? (store == null ? void 0 : store.lang),
    message: config == null ? void 0 : config.message,
    abortEarly: (config == null ? void 0 : config.abortEarly) ?? (store == null ? void 0 : store.abortEarly),
    abortPipeEarly: (config == null ? void 0 : config.abortPipeEarly) ?? (store == null ? void 0 : store.abortPipeEarly),
    skipPipe: (config == null ? void 0 : config.skipPipe) ?? (store == null ? void 0 : store.skipPipe)
  };
}
function getDefault(schema) {
  return typeof schema.default === "function" ? schema.default() : schema.default;
}
async function safeParseAsync(schema, input, config) {
  const result = await schema._parse(input, getGlobalConfig(config));
  return {
    typed: result.typed,
    success: !result.issues,
    data: result.output,
    output: result.output,
    error: result.issues && new ValiError(result.issues),
    issues: result.issues
  };
}

// node_modules/@gcornut/valibot-json-schema/dist/index.mjs
var JSON_SCHEMA_FEATURES_KEY = "__json_schema_features";
function getJSONSchemaFeatures(schema) {
  return schema[JSON_SCHEMA_FEATURES_KEY];
}
function assignExtraJSONSchemaFeatures(schema, converted) {
  const jsonSchemaFeatures = getJSONSchemaFeatures(schema);
  if (jsonSchemaFeatures) {
    Object.assign(converted, jsonSchemaFeatures);
  }
}
function assert2(value, predicate, message) {
  if (!predicate(value))
    throw new Error(message.replace("%", String(value)));
  return value;
}
var $schema = "http://json-schema.org/draft-07/schema#";
function isJSONLiteral(value) {
  return typeof value === "number" && !Number.isNaN(value) || typeof value === "string" || typeof value === "boolean" || value === null;
}
var assertJSONLiteral = (v) => assert2(v, isJSONLiteral, "Unsupported literal value type: %");
function isEqual(obj1, obj2) {
  if (obj1 === obj2)
    return true;
  if (typeof obj1 === "object" && typeof obj2 === "object") {
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);
    if (keys1.length !== keys2.length)
      return false;
    return keys1.every((key1) => isEqual(obj1[key1], obj2[key1]));
  }
  return false;
}
var isSchemaType = (type) => {
  return (schema) => !!schema && schema.type === type;
};
var isNullishSchema = isSchemaType("nullish");
var isOptionalSchema = isSchemaType("optional");
var isStringSchema = isSchemaType("string");
var isNeverSchema = isSchemaType("never");
var toDefinitionURI = (name) => `#/definitions/${name}`;
var SCHEMA_CONVERTERS = {
  any: () => ({}),
  // Core types
  null: () => ({ const: null }),
  literal: ({ literal }) => ({ const: assertJSONLiteral(literal) }),
  number: () => ({ type: "number" }),
  string: () => ({ type: "string" }),
  boolean: () => ({ type: "boolean" }),
  // Compositions
  optional: (schema, convert2) => {
    const output = convert2(schema.wrapped);
    const defaultValue = getDefault(schema);
    if (defaultValue !== void 0)
      output.default = defaultValue;
    return output;
  },
  nullish: (schema, convert2) => {
    const output = { anyOf: [{ const: null }, convert2(schema.wrapped)] };
    const defaultValue = getDefault(schema);
    if (defaultValue !== void 0)
      output.default = defaultValue;
    return output;
  },
  nullable: (schema, convert2) => {
    const output = { anyOf: [{ const: null }, convert2(schema.wrapped)] };
    const defaultValue = getDefault(schema);
    if (defaultValue !== void 0)
      output.default = defaultValue;
    return output;
  },
  picklist: ({ options }) => ({ enum: options.map(assertJSONLiteral) }),
  union: ({ options }, convert2) => ({ anyOf: options.map(convert2) }),
  intersect: ({ options }, convert2) => ({ allOf: options.map(convert2) }),
  // Complex types
  array: ({ item }, convert2) => ({ type: "array", items: convert2(item) }),
  tuple({ items: originalItems, rest, pipe }, convert2) {
    const minItems = originalItems.length;
    let maxItems;
    let items = originalItems.map(convert2);
    let additionalItems;
    if (isNeverSchema(rest)) {
      maxItems = minItems;
    } else if (rest) {
      const restItems = convert2(rest);
      if (items.length === 1 && isEqual(items[0], restItems)) {
        items = items[0];
      } else {
        additionalItems = restItems;
      }
    }
    return { type: "array", items, additionalItems, minItems, maxItems };
  },
  object({ entries, rest }, convert2, context) {
    const properties = {};
    const required = [];
    for (const [propKey, propValue] of Object.entries(entries)) {
      const propSchema = propValue;
      if (!isOptionalSchema(propSchema) && !isNullishSchema(propSchema)) {
        required.push(propKey);
      }
      properties[propKey] = convert2(propSchema);
      assignExtraJSONSchemaFeatures(propValue, properties[propKey]);
    }
    let additionalProperties;
    if (rest) {
      additionalProperties = isNeverSchema(rest) ? false : convert2(rest);
    } else if (context.strictObjectTypes) {
      additionalProperties = false;
    }
    const output = { type: "object", properties };
    if (additionalProperties !== void 0)
      output.additionalProperties = additionalProperties;
    if (required.length)
      output.required = required;
    return output;
  },
  record({ key, value }, convert2) {
    assert2(key, isStringSchema, "Unsupported record key type: %");
    return { type: "object", additionalProperties: convert2(value) };
  },
  recursive(schema, _, context) {
    const nested = schema.getter();
    const defName = context.defNameMap.get(nested);
    if (!defName) {
      throw new Error("Type inside recursive schema must be provided in the definitions");
    }
    return { $ref: toDefinitionURI(defName) };
  },
  date(_, __, context) {
    if (!context.dateStrategy) {
      throw new Error('The "dateStrategy" option must be set to handle date validators');
    }
    switch (context.dateStrategy) {
      case "integer":
        return { type: "integer", format: "unix-time" };
      case "string":
        return { type: "string", format: "date-time" };
    }
  }
};
var VALIDATION_BY_SCHEMA = {
  array: {
    length: ({ requirement }) => ({ minItems: requirement, maxItems: requirement }),
    min_length: ({ requirement }) => ({ minItems: requirement }),
    max_length: ({ requirement }) => ({ maxItems: requirement })
  },
  string: {
    value: ({ requirement }) => ({ const: requirement }),
    length: ({ requirement }) => ({ minLength: requirement, maxLength: requirement }),
    min_length: ({ requirement }) => ({ minLength: requirement }),
    max_length: ({ requirement }) => ({ maxLength: requirement }),
    // TODO: validate RegExp features are compatible with json schema ?
    regex: ({ requirement }) => ({ pattern: requirement.source }),
    email: () => ({ format: "email" }),
    iso_date: () => ({ format: "date" }),
    iso_timestamp: () => ({ format: "date-time" }),
    ipv4: () => ({ format: "ipv4" }),
    ipv6: () => ({ format: "ipv6" }),
    uuid: () => ({ format: "uuid" })
  },
  number: {
    value: ({ requirement }) => ({ const: requirement }),
    min_value: ({ requirement }) => ({ minimum: requirement }),
    max_value: ({ requirement }) => ({ maximum: requirement }),
    multiple_of: ({ requirement }) => ({ multipleOf: requirement }),
    integer: () => ({ type: "integer" })
  },
  boolean: {
    value: ({ requirement }) => ({ const: requirement })
  }
};
function convertPipe(schemaType, ignoreUnknownValidation, pipe = []) {
  return pipe.reduce((def, validation) => {
    var _a;
    const validationType = validation.type;
    const validationConverter = (_a = VALIDATION_BY_SCHEMA[schemaType]) == null ? void 0 : _a[validationType];
    if (!validationConverter && ignoreUnknownValidation)
      return {};
    assert2(validationConverter, Boolean, `Unsupported valibot validation \`${validationType}\` for schema \`${schemaType}\``);
    return Object.assign(def, validationConverter(validation));
  }, {});
}
function getDefNameMap(definitions = {}) {
  const map = /* @__PURE__ */ new Map();
  for (const [name, definition] of Object.entries(definitions)) {
    map.set(definition, name);
  }
  return map;
}
function createConverter(context) {
  const definitions = {};
  function converter(schema) {
    const defName = context.defNameMap.get(schema);
    const defURI = defName && toDefinitionURI(defName);
    if (defURI && defURI in definitions) {
      return { $ref: defURI };
    }
    const schemaConverter = SCHEMA_CONVERTERS[schema.type];
    assert2(schemaConverter, Boolean, `Unsupported valibot schema: ${(schema == null ? void 0 : schema.type) || schema}`);
    const converted = schemaConverter(schema, converter, context);
    Object.assign(converted, convertPipe(schema.type, context.ignoreUnknownValidation, schema.pipe));
    assignExtraJSONSchemaFeatures(schema, converted);
    if (defURI) {
      definitions[defName] = converted;
      return { $ref: defURI };
    }
    return converted;
  }
  return { definitions, converter };
}
function toJSONSchema(options) {
  const { schema, definitions: inputDefinitions, ...more } = options;
  const defNameMap = getDefNameMap(inputDefinitions);
  const { definitions, converter } = createConverter({ defNameMap, ...more });
  if (!schema && !inputDefinitions) {
    throw new Error("No main schema or definitions provided.");
  }
  if (inputDefinitions) {
    Object.values(inputDefinitions).forEach(converter);
  }
  const mainConverted = schema && converter(schema);
  const mainDefName = schema && defNameMap.get(schema);
  const out = { $schema };
  if (mainDefName) {
    out.$ref = toDefinitionURI(mainDefName);
  } else {
    Object.assign(out, mainConverted);
  }
  if (Object.keys(definitions).length) {
    out.definitions = definitions;
  }
  return out;
}

// node_modules/sveltekit-superforms/dist/adapters/valibot.js
var defaultOptions = {
  strictObjectTypes: true,
  dateStrategy: "integer",
  ignoreUnknownValidation: true
};
var valibotToJSONSchema = (options) => {
  return toJSONSchema({ ...defaultOptions, ...options });
};
async function validate4(schema, data, config) {
  const result = await safeParseAsync(schema, data, config);
  if (result.success) {
    return {
      data: result.output,
      success: true
    };
  }
  return {
    issues: result.issues.map(({ message, path }) => ({
      message,
      path: path == null ? void 0 : path.map(({ key }) => key)
    })),
    success: false
  };
}
function _valibot(schema, options = {}) {
  return createAdapter({
    superFormValidationLibrary: "valibot",
    validate: async (data) => validate4(schema, data, options == null ? void 0 : options.config),
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    jsonSchema: (options == null ? void 0 : options.jsonSchema) ?? valibotToJSONSchema({ schema, ...options }),
    defaults: "defaults" in options ? options.defaults : void 0
  });
}
function _valibotClient(schema) {
  return {
    superFormValidationLibrary: "valibot",
    validate: async (data) => validate4(schema, data)
  };
}
var valibot = memoize(_valibot);
var valibotClient = memoize(_valibotClient);

// node_modules/sveltekit-superforms/dist/adapters/yup-to-json-schema/converters/common.js
var commonConverter = (description, converters) => {
  var _a, _b;
  const jsonSchema = {};
  jsonSchema.type = description.type;
  if (description.nullable) {
    jsonSchema.type = [jsonSchema.type, "null"];
  }
  if (((_a = description.oneOf) == null ? void 0 : _a.length) > 0) {
    jsonSchema.enum = description.oneOf;
  }
  if (((_b = description.notOneOf) == null ? void 0 : _b.length) > 0) {
    jsonSchema.not = {
      enum: description.notOneOf
    };
  }
  if (description.label) {
    jsonSchema.title = description.label;
  }
  if (description.default !== void 0) {
    jsonSchema.default = description.default;
  }
  return jsonSchema;
};
var common_default = commonConverter;

// node_modules/sveltekit-superforms/dist/adapters/yup-to-json-schema/converters/string.js
var uuidRegExPattern = "^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$";
var stringConverter = (description, converters) => {
  const jsonSchema = common_default(description, converters);
  const meta = description.meta || {};
  description.tests.forEach((test) => {
    var _a, _b, _c, _d;
    switch (test.name) {
      case "length":
        if (((_a = test.params) == null ? void 0 : _a.length) !== void 0) {
          jsonSchema.minLength = Number(test.params.length);
          jsonSchema.maxLength = Number(test.params.length);
        }
        break;
      case "min":
        if (((_b = test.params) == null ? void 0 : _b.min) !== void 0) {
          jsonSchema.minLength = Number(test.params.min);
        }
        break;
      case "max":
        if (((_c = test.params) == null ? void 0 : _c.max) !== void 0) {
          jsonSchema.maxLength = Number(test.params.max);
        }
        break;
      case "matches":
        if ((_d = test.params) == null ? void 0 : _d.regex) {
          jsonSchema.pattern = test.params.regex.toString().replace(/^\/(.*)\/[gimusy]*$/, "$1");
        }
        break;
      case "email":
        jsonSchema.format = "email";
        break;
      case "url":
        jsonSchema.format = "uri";
        break;
      case "uuid":
        jsonSchema.format = "uuid";
        jsonSchema.pattern = uuidRegExPattern;
        break;
    }
  });
  return Object.assign(jsonSchema, meta.jsonSchema);
};
var string_default = stringConverter;

// node_modules/sveltekit-superforms/dist/adapters/yup-to-json-schema/converters/number.js
var numberConverter = (description, converters) => {
  const jsonSchema = common_default(description, converters);
  const meta = description.meta || {};
  description.tests.forEach((test) => {
    var _a, _b, _c, _d;
    switch (test.name) {
      case "min":
        if (((_a = test.params) == null ? void 0 : _a.min) !== void 0) {
          jsonSchema.minimum = Number(test.params.min);
        }
        if (((_b = test.params) == null ? void 0 : _b.more) !== void 0) {
          jsonSchema.exclusiveMinimum = Number(test.params.more);
        }
        break;
      case "max":
        if (((_c = test.params) == null ? void 0 : _c.max) !== void 0) {
          jsonSchema.maximum = Number(test.params.max);
        }
        if (((_d = test.params) == null ? void 0 : _d.less) !== void 0) {
          jsonSchema.exclusiveMaximum = Number(test.params.less);
        }
        break;
      case "integer":
        if (jsonSchema.type === "number") {
          jsonSchema.type = "integer";
        } else {
          jsonSchema.type = [...jsonSchema.type, "integer"].filter((type) => type !== "number");
        }
    }
  });
  return Object.assign(jsonSchema, meta.jsonSchema);
};
var number_default = numberConverter;

// node_modules/sveltekit-superforms/dist/adapters/yup-to-json-schema/converters/boolean.js
var booleanConverter = (description, converters) => {
  const jsonSchema = common_default(description, converters);
  const meta = description.meta || {};
  return Object.assign(jsonSchema, meta.jsonSchema);
};
var boolean_default = booleanConverter;

// node_modules/sveltekit-superforms/dist/adapters/yup-to-json-schema/converters/date.js
var dateConverter = (description, converters) => {
  const jsonSchema = common_default(description, converters);
  const meta = description.meta || {};
  jsonSchema.type = "string";
  jsonSchema.format = "date-time";
  return Object.assign(jsonSchema, meta.jsonSchema);
};
var date_default = dateConverter;

// node_modules/sveltekit-superforms/dist/adapters/yup-to-json-schema/converters/array.js
var arrayConverter = (description, converters) => {
  const jsonSchema = common_default(description, converters);
  const meta = description.meta || {};
  const { innerType } = description;
  if (innerType) {
    const converter = converters[innerType.type];
    jsonSchema.items = converter(innerType, converters);
  }
  description.tests.forEach((test) => {
    var _a, _b, _c;
    switch (test.name) {
      case "length":
        if (((_a = test.params) == null ? void 0 : _a.length) !== void 0) {
          jsonSchema.minItems = jsonSchema.maxItems = Number(test.params.length);
        }
        break;
      case "min":
        if (((_b = test.params) == null ? void 0 : _b.min) !== void 0) {
          jsonSchema.minItems = Number(test.params.min);
        }
        break;
      case "max":
        if (((_c = test.params) == null ? void 0 : _c.max) !== void 0) {
          jsonSchema.maxItems = Number(test.params.max);
        }
        break;
    }
  });
  return Object.assign(jsonSchema, meta.jsonSchema);
};
var array_default = arrayConverter;

// node_modules/sveltekit-superforms/dist/adapters/yup-to-json-schema/converters/object.js
var objectConverter = (description, converters) => {
  const jsonSchema = common_default(description, converters);
  const meta = description.meta || {};
  const properties = {};
  const required = [];
  Object.keys(description.fields).forEach((fieldName) => {
    const fieldDescription = description.fields[fieldName];
    const converter = converters[fieldDescription.type];
    properties[fieldName] = converter(fieldDescription, converters);
    if (!fieldDescription.optional) {
      required.push(fieldName);
    }
  });
  if (Object.keys(properties).length > 0) {
    jsonSchema.properties = properties;
  }
  if (Object.keys(required).length > 0) {
    jsonSchema.required = required;
  }
  return Object.assign(jsonSchema, meta.jsonSchema);
};
var object_default = objectConverter;

// node_modules/sveltekit-superforms/dist/adapters/yup-to-json-schema/converters/tuple.js
var tupleConverter = (description, converters) => {
  const jsonSchema = common_default(description, converters);
  const meta = description.meta || {};
  jsonSchema.type = "array";
  jsonSchema.items = description.innerType.map((description2) => {
    const converter = converters[description2.type];
    return converter(description2, converters);
  });
  jsonSchema.minItems = jsonSchema.items.length;
  jsonSchema.maxItems = jsonSchema.items.length;
  return Object.assign(jsonSchema, meta.jsonSchema);
};
var tuple_default = tupleConverter;

// node_modules/sveltekit-superforms/dist/adapters/yup-to-json-schema/converters/mixed.js
var getType = (item) => {
  switch (typeof item) {
    case "string":
      return "string";
    case "number":
      return "number";
    case "boolean":
      return "boolean";
    case "object":
      if (Array.isArray(item)) {
        return "array";
      } else if (item === null) {
        return "null";
      } else if (item instanceof Date) {
        return "string";
      } else {
        return "object";
      }
    default:
      return "null";
  }
};
var mixedConverter = (description, converters) => {
  var _a;
  const jsonSchema = common_default(description, converters);
  const meta = description.meta || {};
  let types = Array.isArray(description.type) ? description.type : [description.type];
  types = types.filter((type) => type !== "mixed");
  if (((_a = description.oneOf) == null ? void 0 : _a.length) > 0) {
    description.oneOf.forEach((item) => {
      types.push(getType(item));
    });
  }
  if (description.default !== void 0) {
    types.push(getType(description.default));
  }
  types = types.filter((type, index, self) => self.indexOf(type) === index);
  jsonSchema.type = types;
  return Object.assign(jsonSchema, meta.jsonSchema);
};
var mixed_default = mixedConverter;

// node_modules/sveltekit-superforms/dist/adapters/yup-to-json-schema/converters/lazy.js
var lazyConverter = (description, converters) => {
  const jsonSchema = common_default(description, converters);
  const meta = description.meta || {};
  return Object.assign(jsonSchema, meta.jsonSchema);
};
var lazy_default = lazyConverter;

// node_modules/sveltekit-superforms/dist/adapters/yup-to-json-schema/converters/index.js
function convertSchema(yupSchema, options) {
  const { converters, ...resolveOptions } = options || {};
  const allConverters = {
    string: string_default,
    number: number_default,
    boolean: boolean_default,
    date: date_default,
    array: array_default,
    object: object_default,
    tuple: tuple_default,
    mixed: mixed_default,
    lazy: lazy_default,
    ...converters
  };
  const description = yupSchema.describe(resolveOptions);
  const converter = allConverters[description.type];
  return converter(description, allConverters);
}

// node_modules/sveltekit-superforms/dist/adapters/yup.js
var modules2 = async () => {
  const { ValidationError } = await import(
    /* webpackIgnore: true */
    "./index.esm-C4N7WOU6.js"
  );
  return { ValidationError };
};
var fetchModule2 = memoize(modules2);
function yupToJSONSchema(schema) {
  return convertSchema(schema, {
    converters: {
      date: (desc, options) => {
        return options.string(desc, options);
      }
    }
  });
}
async function validate5(schema, data) {
  const { ValidationError } = await fetchModule2();
  try {
    return {
      success: true,
      data: await schema.validate(data, { strict: true, abortEarly: false })
    };
  } catch (error) {
    if (!(error instanceof ValidationError))
      throw error;
    return {
      success: false,
      issues: error.inner.map((error2) => ({
        message: error2.message,
        path: error2.path !== null && error2.path !== void 0 ? splitPath(error2.path) : void 0
      }))
    };
  }
}
function _yup(schema, options) {
  return createAdapter({
    superFormValidationLibrary: "yup",
    validate: async (data) => validate5(schema, data),
    jsonSchema: (options == null ? void 0 : options.jsonSchema) ?? yupToJSONSchema(schema),
    defaults: options == null ? void 0 : options.defaults
  });
}
function _yupClient(schema) {
  return {
    superFormValidationLibrary: "yup",
    validate: async (data) => validate5(schema, data)
  };
}
var yup = memoize(_yup);
var yupClient = memoize(_yupClient);

// node_modules/zod-to-json-schema/dist/esm/errorMessages.js
function addErrorMessage(res, key, errorMessage, refs) {
  if (!(refs == null ? void 0 : refs.errorMessages))
    return;
  if (errorMessage) {
    res.errorMessage = {
      ...res.errorMessage,
      [key]: errorMessage
    };
  }
}
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage(res, key, errorMessage, refs);
}

// node_modules/zod-to-json-schema/dist/esm/Options.js
var defaultOptions2 = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "string",
  mapStrategy: "entries",
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  emailStrategy: "format:email"
};
var getDefaultOptions = (options) => typeof options === "string" ? {
  ...defaultOptions2,
  name: options
} : {
  ...defaultOptions2,
  ...options
};

// node_modules/zod-to-json-schema/dist/esm/parsers/any.js
function parseAnyDef() {
  return {};
}

// node_modules/zod-to-json-schema/dist/esm/parsers/array.js
function parseArrayDef(def, refs) {
  var _a, _b;
  const res = {
    type: "array"
  };
  if (((_b = (_a = def.type) == null ? void 0 : _a._def) == null ? void 0 : _b.typeName) !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js
function parseBigintDef(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js
function parseBooleanDef() {
  return {
    type: "boolean"
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/branded.js
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}

// node_modules/zod-to-json-schema/dist/esm/parsers/catch.js
var parseCatchDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// node_modules/zod-to-json-schema/dist/esm/parsers/date.js
function parseDateDef(def, refs) {
  if (refs.dateStrategy == "integer") {
    return integerDateParser(def, refs);
  } else {
    return {
      type: "string",
      format: "date-time"
    };
  }
}
var integerDateParser = (def, refs) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          setResponseValueAndErrors(
            res,
            "minimum",
            check.value,
            // This is in milliseconds
            check.message,
            refs
          );
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          setResponseValueAndErrors(
            res,
            "maximum",
            check.value,
            // This is in milliseconds
            check.message,
            refs
          );
        }
        break;
    }
  }
  return res;
};

// node_modules/zod-to-json-schema/dist/esm/parsers/default.js
function parseDefaultDef(_def, refs) {
  return {
    ...parseDef(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/effects.js
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : {};
}

// node_modules/zod-to-json-schema/dist/esm/parsers/enum.js
function parseEnumDef(def) {
  return {
    type: "string",
    enum: def.values
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js
var isJsonSchema7AllOfType = (type) => {
  if ("type" in type && type.type === "string")
    return false;
  return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0) {
        unevaluatedProperties = void 0;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else {
        unevaluatedProperties = void 0;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : void 0;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/literal.js
function parseLiteralDef(def, refs) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      enum: [def.value]
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/string.js
var zodPatterns = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: "^[cC][^\\s-]{8,}$",
  cuid2: "^[a-z][a-z0-9]*$",
  ulid: "^[0-9A-HJKMNP-TV-Z]{26}$",
  /**
   * `a-z` was added to replicate /i flag
   */
  email: "^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_+-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$",
  emoji: "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
  /**
   * Unused
   */
  uuid: "^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$",
  /**
   * Unused
   */
  ipv4: "^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$",
  /**
   * Unused
   */
  ipv6: "^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$"
};
function parseStringDef(def, refs) {
  const res = {
    type: "string"
  };
  function processPattern(value) {
    return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(value) : value;
  }
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          break;
        case "max":
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern(res, check.regex.source, check.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern(res, "^" + processPattern(check.value), check.message, refs);
          break;
        case "endsWith":
          addPattern(res, processPattern(check.value) + "$", check.message, refs);
          break;
        case "datetime":
          addFormat(res, "date-time", check.message, refs);
          break;
        case "length":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "includes": {
          addPattern(res, processPattern(check.value), check.message, refs);
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji, check.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check.message, refs);
          break;
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          /* @__PURE__ */ ((_) => {
          })(check);
      }
    }
  }
  return res;
}
var escapeNonAlphaNumeric = (value) => Array.from(value).map((c) => /[a-zA-Z0-9]/.test(c) ? c : `\\${c}`).join("");
var addFormat = (schema, value, message, refs) => {
  var _a;
  if (schema.format || ((_a = schema.anyOf) == null ? void 0 : _a.some((x) => x.format))) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { format: schema.errorMessage.format }
        }
      });
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "format", value, message, refs);
  }
};
var addPattern = (schema, value, message, refs) => {
  var _a;
  if (schema.pattern || ((_a = schema.allOf) == null ? void 0 : _a.some((x) => x.pattern))) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { pattern: schema.errorMessage.pattern }
        }
      });
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.allOf.push({
      pattern: value,
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "pattern", value, message, refs);
  }
};

// node_modules/zod-to-json-schema/dist/esm/parsers/record.js
function parseRecordDef(def, refs) {
  var _a, _b, _c, _d;
  if (refs.target === "openApi3" && ((_a = def.keyType) == null ? void 0 : _a._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key) => ({
        ...acc,
        [key]: parseDef(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", key]
        }) ?? {}
      }), {}),
      additionalProperties: false
    };
  }
  const schema = {
    type: "object",
    additionalProperties: parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? {}
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (((_b = def.keyType) == null ? void 0 : _b._def.typeName) === ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
    const keyType = Object.entries(parseStringDef(def.keyType._def, refs)).reduce((acc, [key, value]) => key === "type" ? acc : { ...acc, [key]: value }, {});
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  }
  return schema;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/map.js
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys = parseDef(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || {};
  const values = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js
function parseNativeEnumDef(def) {
  const object = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object[object[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/never.js
function parseNeverDef() {
  return {
    not: {}
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/null.js
function parseNullDef(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/union.js
var primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, [])
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce((acc, x) => [
        ...acc,
        ...x._def.values.filter((x2) => !acc.includes(x2))
      ], [])
    };
  }
  return asAnyOf(def, refs);
}
var asAnyOf = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef(x._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", `${i}`]
  })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
  return anyOf.length ? { anyOf } : void 0;
};

// node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") {
      return {
        type: primitiveMappings[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [
        primitiveMappings[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  if (refs.target === "openApi3") {
    const base2 = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base2 && "$ref" in base2)
      return { allOf: [base2], nullable: true };
    return base2 && { ...base2, nullable: true };
  }
  const base = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/number.js
function parseNumberDef(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage(res, "type", check.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/object.js
function parseObjectDef(def, refs) {
  const result = {
    type: "object",
    ...Object.entries(def.shape()).reduce((acc, [propName, propDef]) => {
      if (propDef === void 0 || propDef._def === void 0)
        return acc;
      const parsedDef = parseDef(propDef._def, {
        ...refs,
        currentPath: [...refs.currentPath, "properties", propName],
        propertyPath: [...refs.currentPath, "properties", propName]
      });
      if (parsedDef === void 0)
        return acc;
      return {
        properties: { ...acc.properties, [propName]: parsedDef },
        required: propDef.isOptional() ? acc.required : [...acc.required, propName]
      };
    }, { properties: {}, required: [] }),
    additionalProperties: def.catchall._def.typeName === "ZodNever" ? def.unknownKeys === "passthrough" : parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? true
  };
  if (!result.required.length)
    delete result.required;
  return result;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/optional.js
var parseOptionalDef = (def, refs) => {
  var _a;
  if (refs.currentPath.toString() === ((_a = refs.propertyPath) == null ? void 0 : _a.toString())) {
    return parseDef(def.innerType._def, refs);
  }
  const innerSchema = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? {
    anyOf: [
      {
        not: {}
      },
      innerSchema
    ]
  } : {};
};

// node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js
var parsePipelineDef = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef(def.out._def, refs);
  }
  const a = parseDef(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
};

// node_modules/zod-to-json-schema/dist/esm/parsers/promise.js
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}

// node_modules/zod-to-json-schema/dist/esm/parsers/set.js
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
      additionalItems: parseDef(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
    };
  }
}

// node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js
function parseUndefinedDef() {
  return {
    not: {}
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js
function parseUnknownDef() {
  return {};
}

// node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js
var parseReadonlyDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// node_modules/zod-to-json-schema/dist/esm/parseDef.js
function parseDef(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchema = selectParser(def, def.typeName, refs);
  if (jsonSchema) {
    addMeta(def, refs, jsonSchema);
  }
  newItem.jsonSchema = jsonSchema;
  return jsonSchema;
}
var get$ref = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return {};
      }
      return refs.$refStrategy === "seen" ? {} : void 0;
    }
  }
};
var getRelativePath = (pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i])
      break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};
var selectParser = (def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef(def, refs);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef();
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef(refs);
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef(def, refs);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return parseDef(def.getter()._def, refs);
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef();
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef(def, refs);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef();
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef();
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)(typeName);
  }
};
var addMeta = (def, refs, jsonSchema) => {
  if (def.description) {
    jsonSchema.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema.markdownDescription = def.description;
    }
  }
  return jsonSchema;
};

// node_modules/zod-to-json-schema/dist/esm/Refs.js
var getRefs = (options) => {
  const _options = getDefaultOptions(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    currentPath,
    propertyPath: void 0,
    seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [
      def._def,
      {
        def: def._def,
        path: [..._options.basePath, _options.definitionPath, name],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
};

// node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js
var zodToJsonSchema = (schema, options) => {
  const refs = getRefs(options);
  const definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name2, schema2]) => ({
    ...acc,
    [name2]: parseDef(schema2._def, {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name2]
    }, true) ?? {}
  }), {}) : void 0;
  const name = typeof options === "string" ? options : options == null ? void 0 : options.name;
  const main = parseDef(schema._def, name === void 0 ? refs : {
    ...refs,
    currentPath: [...refs.basePath, refs.definitionPath, name]
  }, false) ?? {};
  const combined = name === void 0 ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name]: main
    }
  };
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  return combined;
};

// node_modules/sveltekit-superforms/dist/adapters/zod.js
var defaultOptions3 = {
  dateStrategy: "integer",
  pipeStrategy: "output"
};
var zodToJSONSchema = (...params) => {
  params[1] = typeof params[1] == "object" ? { ...defaultOptions3, ...params[1] } : defaultOptions3;
  return zodToJsonSchema(...params);
};
async function validate6(schema, data) {
  const result = await schema.safeParseAsync(data);
  if (result.success) {
    return {
      data: result.data,
      success: true
    };
  }
  return {
    issues: result.error.issues.map(({ message, path }) => ({ message, path })),
    success: false
  };
}
function _zod(schema, options) {
  return createAdapter({
    superFormValidationLibrary: "zod",
    validate: async (data) => validate6(schema, data),
    jsonSchema: (options == null ? void 0 : options.jsonSchema) ?? zodToJSONSchema(schema),
    defaults: options == null ? void 0 : options.defaults
  });
}
function _zodClient(schema) {
  return {
    superFormValidationLibrary: "zod",
    validate: async (data) => validate6(schema, data)
  };
}
var zod = memoize(_zod);
var zodClient = memoize(_zodClient);

// node_modules/sveltekit-superforms/dist/adapters/vine.js
async function modules3() {
  const { Vine, errors } = await import(
    /* webpackIgnore: true */
    "./build-EUWX3HOK.js"
  );
  return { Vine, errors };
}
var fetchModule3 = memoize(modules3);
async function validate7(schema, data) {
  const { Vine, errors } = await fetchModule3();
  try {
    const output = await new Vine().validate({ schema, data });
    return {
      success: true,
      data: output
    };
  } catch (e) {
    if (e instanceof errors.E_VALIDATION_ERROR) {
      return {
        success: false,
        issues: e.messages.map((m) => ({
          path: m.field.split("."),
          message: m.message
        }))
      };
    } else {
      return { success: false, issues: [] };
    }
  }
}
function _vine(schema, options) {
  return createAdapter({
    superFormValidationLibrary: "vine",
    validate: async (data) => validate7(schema, data),
    jsonSchema: createJsonSchema(options),
    defaults: options.defaults
  });
}
function _vineClient(schema) {
  return {
    superFormValidationLibrary: "vine",
    validate: async (data) => validate7(schema, data)
  };
}
var vine = memoize(_vine);
var vineClient = memoize(_vineClient);
export {
  arktype,
  arktypeClient,
  joi,
  joiClient,
  superformClient,
  typebox,
  typeboxClient,
  valibot,
  valibotClient,
  vine,
  vineClient,
  yup,
  yupClient,
  zod,
  zodClient
};
//# sourceMappingURL=sveltekit-superforms_adapters.js.map
