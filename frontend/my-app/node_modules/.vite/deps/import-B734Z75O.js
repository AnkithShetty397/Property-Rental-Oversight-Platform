import {
  Any,
  Array,
  AsyncIterator,
  BigInt,
  Boolean,
  Clone,
  CloneRest,
  CloneType,
  Constructor,
  Discard,
  Extends,
  ExtendsCheck,
  ExtendsFromMappedKey,
  ExtendsFromMappedResult,
  ExtendsResolverError,
  ExtendsResult,
  ExtendsUndefinedCheck,
  Function,
  Hint,
  Index,
  IndexFromMappedKey,
  IndexFromMappedResult,
  IndexFromPropertyKey,
  IndexFromPropertyKeys,
  IndexPropertyKeys,
  Intersect,
  IntersectEvaluated,
  IsArray,
  IsArray2,
  IsAsyncIterator,
  IsAsyncIterator2,
  IsBigInt,
  IsBoolean,
  IsConstructor,
  IsDate,
  IsFunction,
  IsFunction2,
  IsInteger,
  IsIntersect,
  IsIterator,
  IsIterator2,
  IsLiteral,
  IsMappedKey,
  IsMappedResult,
  IsNever,
  IsNull,
  IsNumber,
  IsNumber2,
  IsObject,
  IsObject2,
  IsPromise,
  IsRef,
  IsRegExp,
  IsSchema,
  IsString,
  IsString2,
  IsSymbol,
  IsTemplateLiteral,
  IsTemplateLiteralExpressionFinite,
  IsTemplateLiteralFinite,
  IsTransform,
  IsTuple,
  IsUint8Array,
  IsUndefined,
  IsUnion,
  Iterator,
  KeyOf,
  KeyOfFromMappedResult,
  KeyOfPattern,
  KeyOfPropertyKeys,
  KeyOfPropertyKeysToRest,
  Kind,
  Literal,
  Mapped,
  MappedFunctionReturnType,
  MappedKey,
  MappedResult,
  Never,
  Number,
  Object,
  Optional,
  OptionalFromMappedResult,
  OptionalKind,
  PatternBoolean,
  PatternBooleanExact,
  PatternNumber,
  PatternNumberExact,
  PatternString,
  PatternStringExact,
  Promise as Promise2,
  Readonly,
  ReadonlyFromMappedResult,
  ReadonlyKind,
  SetComplement,
  SetDistinct,
  SetIncludes,
  SetIntersect,
  SetIntersectMany,
  SetIsSubset,
  SetUnion,
  SetUnionMany,
  String,
  TemplateLiteral,
  TemplateLiteralExpressionGenerate,
  TemplateLiteralFiniteError,
  TemplateLiteralGenerate,
  TemplateLiteralGenerateError,
  TemplateLiteralParse,
  TemplateLiteralParseExact,
  TemplateLiteralParserError,
  TemplateLiteralPattern,
  TemplateLiteralPatternError,
  TemplateLiteralSyntax,
  TemplateLiteralToUnion,
  TransformKind,
  Tuple,
  TypeBoxError,
  Union,
  UnionEvaluated,
  Unknown,
  Unsafe,
  format_exports,
  type_exports,
  type_exports2,
  value_exports
} from "./chunk-5PBZDHGQ.js";
import {
  __export,
  __publicField
} from "./chunk-OSJZHPF7.js";

// node_modules/@sinclair/typebox/build/import/type/helpers/helpers.mjs
function Increment(T) {
  return (parseInt(T) + 1).toString();
}

// node_modules/@sinclair/typebox/build/import/type/awaited/awaited.mjs
function FromRest(T) {
  return T.map((L) => AwaitedResolve(L));
}
function FromIntersect(T) {
  return Intersect(FromRest(T));
}
function FromUnion(T) {
  return Union(FromRest(T));
}
function FromPromise(T) {
  return AwaitedResolve(T);
}
function AwaitedResolve(T) {
  return IsIntersect(T) ? FromIntersect(T.allOf) : IsUnion(T) ? FromUnion(T.anyOf) : IsPromise(T) ? FromPromise(T.item) : T;
}
function Awaited(T, options = {}) {
  return CloneType(AwaitedResolve(T), options);
}

// node_modules/@sinclair/typebox/build/import/type/composite/composite.mjs
function CompositeKeys(T) {
  return T.reduce((Acc, L) => {
    return SetDistinct([...Acc, ...KeyOfPropertyKeys(L)]);
  }, []);
}
function FilterNever(T) {
  return T.filter((L) => !IsNever(L));
}
function CompositeProperty(T, K) {
  return T.reduce((Acc, L) => {
    return FilterNever([...Acc, ...IndexFromPropertyKeys(L, [K])]);
  }, []);
}
function CompositeProperties(T, K) {
  return K.reduce((Acc, L) => {
    return { ...Acc, [L]: IntersectEvaluated(CompositeProperty(T, L)) };
  }, {});
}
function Composite(T, options = {}) {
  const K = CompositeKeys(T);
  const P = CompositeProperties(T, K);
  const R = Object(P, options);
  return R;
}

// node_modules/@sinclair/typebox/build/import/type/date/date.mjs
function Date(options = {}) {
  return {
    ...options,
    [Kind]: "Date",
    type: "Date"
  };
}

// node_modules/@sinclair/typebox/build/import/type/null/null.mjs
function Null(options = {}) {
  return {
    ...options,
    [Kind]: "Null",
    type: "null"
  };
}

// node_modules/@sinclair/typebox/build/import/type/symbol/symbol.mjs
function Symbol(options) {
  return { ...options, [Kind]: "Symbol", type: "symbol" };
}

// node_modules/@sinclair/typebox/build/import/type/undefined/undefined.mjs
function Undefined(options = {}) {
  return { ...options, [Kind]: "Undefined", type: "undefined" };
}

// node_modules/@sinclair/typebox/build/import/type/uint8array/uint8array.mjs
function Uint8Array(options = {}) {
  return { ...options, [Kind]: "Uint8Array", type: "Uint8Array" };
}

// node_modules/@sinclair/typebox/build/import/type/const/const.mjs
function FromArray(T) {
  return T.map((L) => FromValue(L, false));
}
function FromProperties(value) {
  return globalThis.Object.getOwnPropertyNames(value).reduce((acc, key) => {
    return { ...acc, [key]: Readonly(FromValue(value[key], false)) };
  }, {});
}
function ConditionalReadonly(T, root) {
  return root === true ? T : Readonly(T);
}
function FromValue(value, root) {
  return IsAsyncIterator(value) ? ConditionalReadonly(Any(), root) : IsIterator(value) ? ConditionalReadonly(Any(), root) : IsArray(value) ? Readonly(Tuple(FromArray(value))) : IsUint8Array(value) ? Uint8Array() : IsDate(value) ? Date() : IsObject(value) ? ConditionalReadonly(Object(FromProperties(value)), root) : IsFunction(value) ? ConditionalReadonly(Function([], Unknown()), root) : IsUndefined(value) ? Undefined() : IsNull(value) ? Null() : IsSymbol(value) ? Symbol() : IsBigInt(value) ? BigInt() : IsNumber(value) ? Literal(value) : IsBoolean(value) ? Literal(value) : IsString(value) ? Literal(value) : Object({});
}
function Const(T, options = {}) {
  return CloneType(FromValue(T, true), options);
}

// node_modules/@sinclair/typebox/build/import/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}

// node_modules/@sinclair/typebox/build/import/type/deref/deref.mjs
function FromRest2(schema, references) {
  return schema.map((schema2) => Deref(schema2, references));
}
function FromProperties2(properties, references) {
  return globalThis.Object.getOwnPropertyNames(properties).reduce((acc, key) => {
    return { ...acc, [key]: Deref(properties[key], references) };
  }, {});
}
function FromConstructor(schema, references) {
  schema.parameters = FromRest2(schema.parameters, references);
  schema.returns = Deref(schema.returns, references);
  return schema;
}
function FromFunction(schema, references) {
  schema.parameters = FromRest2(schema.parameters, references);
  schema.returns = Deref(schema.returns, references);
  return schema;
}
function FromIntersect2(schema, references) {
  schema.allOf = FromRest2(schema.allOf, references);
  return schema;
}
function FromUnion2(schema, references) {
  schema.anyOf = FromRest2(schema.anyOf, references);
  return schema;
}
function FromTuple(schema, references) {
  if (IsUndefined(schema.items))
    return schema;
  schema.items = FromRest2(schema.items, references);
  return schema;
}
function FromArray2(schema, references) {
  schema.items = Deref(schema.items, references);
  return schema;
}
function FromObject(schema, references) {
  schema.properties = FromProperties2(schema.properties, references);
  return schema;
}
function FromPromise2(schema, references) {
  schema.item = Deref(schema.item, references);
  return schema;
}
function FromAsyncIterator(schema, references) {
  schema.items = Deref(schema.items, references);
  return schema;
}
function FromIterator(schema, references) {
  schema.items = Deref(schema.items, references);
  return schema;
}
function FromRef(schema, references) {
  const target = references.find((remote) => remote.$id === schema.$ref);
  if (target === void 0)
    throw Error(`Unable to dereference schema with $id ${schema.$ref}`);
  const discard = Discard(target, ["$id"]);
  return Deref(discard, references);
}
function DerefResolve(schema, references) {
  return IsConstructor(schema) ? FromConstructor(schema, references) : IsFunction2(schema) ? FromFunction(schema, references) : IsIntersect(schema) ? FromIntersect2(schema, references) : IsUnion(schema) ? FromUnion2(schema, references) : IsTuple(schema) ? FromTuple(schema, references) : IsArray2(schema) ? FromArray2(schema, references) : IsObject2(schema) ? FromObject(schema, references) : IsPromise(schema) ? FromPromise2(schema, references) : IsAsyncIterator2(schema) ? FromAsyncIterator(schema, references) : IsIterator2(schema) ? FromIterator(schema, references) : IsRef(schema) ? FromRef(schema, references) : schema;
}
function Deref(schema, references) {
  return DerefResolve(CloneType(schema), CloneRest(references));
}

// node_modules/@sinclair/typebox/build/import/type/enum/enum.mjs
function Enum(item, options = {}) {
  if (IsUndefined(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value) => Literal(value));
  return Union(anyOf, { ...options, [Hint]: "Enum" });
}

// node_modules/@sinclair/typebox/build/import/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral(L, R) {
  return Exclude(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/import/type/exclude/exclude.mjs
function ExcludeRest(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
  return excluded.length === 1 ? excluded[0] : Union(excluded);
}
function Exclude(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExcludeFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExcludeFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExcludeRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);
}

// node_modules/@sinclair/typebox/build/import/type/exclude/exclude-from-mapped-result.mjs
function FromProperties3(P, U) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Exclude(P[K2], U) };
  }, {});
}
function FromMappedResult(R, T) {
  return FromProperties3(R.properties, T);
}
function ExcludeFromMappedResult(R, T) {
  const P = FromMappedResult(R, T);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral(L, R) {
  return Extract(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/import/type/extract/extract.mjs
function ExtractRest(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
  return extracted.length === 1 ? extracted[0] : Union(extracted);
}
function Extract(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExtractFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExtractFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExtractRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);
}

// node_modules/@sinclair/typebox/build/import/type/extract/extract-from-mapped-result.mjs
function FromProperties4(P, T) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Extract(P[K2], T) };
  }, {});
}
function FromMappedResult2(R, T) {
  return FromProperties4(R.properties, T);
}
function ExtractFromMappedResult(R, T) {
  const P = FromMappedResult2(R, T);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/instance-type/instance-type.mjs
function InstanceType(schema, options = {}) {
  return CloneType(schema.returns, options);
}

// node_modules/@sinclair/typebox/build/import/type/integer/integer.mjs
function Integer(options = {}) {
  return {
    ...options,
    [Kind]: "Integer",
    type: "integer"
  };
}

// node_modules/@sinclair/typebox/build/import/type/intrinsic/intrinsic-from-mapped-key.mjs
function MappedIntrinsicPropertyKey(K, M, options) {
  return {
    [K]: Intrinsic(Literal(K), M, options)
  };
}
function MappedIntrinsicPropertyKeys(K, M, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
  }, {});
}
function MappedIntrinsicProperties(T, M, options) {
  return MappedIntrinsicPropertyKeys(T["keys"], M, options);
}
function IntrinsicFromMappedKey(T, M, options) {
  const P = MappedIntrinsicProperties(T, M, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/intrinsic/intrinsic.mjs
function ApplyUncapitalize(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toLowerCase(), rest].join("");
}
function ApplyCapitalize(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toUpperCase(), rest].join("");
}
function ApplyUppercase(value) {
  return value.toUpperCase();
}
function ApplyLowercase(value) {
  return value.toLowerCase();
}
function FromTemplateLiteral(schema, mode, options) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  const finite = IsTemplateLiteralExpressionFinite(expression);
  if (!finite)
    return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate(expression)];
  const literals = strings.map((value) => Literal(value));
  const mapped = FromRest3(literals, mode);
  const union = Union(mapped);
  return TemplateLiteral([union], options);
}
function FromLiteralValue(value, mode) {
  return typeof value === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value) : mode === "Capitalize" ? ApplyCapitalize(value) : mode === "Uppercase" ? ApplyUppercase(value) : mode === "Lowercase" ? ApplyLowercase(value) : value : value.toString();
}
function FromRest3(T, M) {
  return T.map((L) => Intrinsic(L, M));
}
function Intrinsic(schema, mode, options = {}) {
  return (
    // Intrinsic-Mapped-Inference
    IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) : (
      // Standard-Inference
      IsTemplateLiteral(schema) ? FromTemplateLiteral(schema, mode, schema) : IsUnion(schema) ? Union(FromRest3(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) : schema
    )
  );
}

// node_modules/@sinclair/typebox/build/import/type/intrinsic/capitalize.mjs
function Capitalize(T, options = {}) {
  return Intrinsic(T, "Capitalize", options);
}

// node_modules/@sinclair/typebox/build/import/type/intrinsic/lowercase.mjs
function Lowercase(T, options = {}) {
  return Intrinsic(T, "Lowercase", options);
}

// node_modules/@sinclair/typebox/build/import/type/intrinsic/uncapitalize.mjs
function Uncapitalize(T, options = {}) {
  return Intrinsic(T, "Uncapitalize", options);
}

// node_modules/@sinclair/typebox/build/import/type/intrinsic/uppercase.mjs
function Uppercase(T, options = {}) {
  return Intrinsic(T, "Uppercase", options);
}

// node_modules/@sinclair/typebox/build/import/type/not/not.mjs
function Not(schema, options) {
  return {
    ...options,
    [Kind]: "Not",
    not: CloneType(schema)
  };
}

// node_modules/@sinclair/typebox/build/import/type/omit/omit-from-mapped-result.mjs
function FromProperties5(P, K, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Omit(P[K2], K, options) };
  }, {});
}
function FromMappedResult3(R, K, options) {
  return FromProperties5(R.properties, K, options);
}
function OmitFromMappedResult(R, K, options) {
  const P = FromMappedResult3(R, K, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/omit/omit.mjs
function FromIntersect3(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
}
function FromUnion3(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
}
function FromProperty(T, K) {
  const { [K]: _, ...R } = T;
  return R;
}
function FromProperties6(T, K) {
  return K.reduce((T2, K2) => {
    return FromProperty(T2, K2);
  }, T);
}
function OmitResolve(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect3(T.allOf, K)) : IsUnion(T) ? Union(FromUnion3(T.anyOf, K)) : IsObject2(T) ? Object(FromProperties6(T.properties, K)) : Object({});
}
function Omit(T, K, options = {}) {
  if (IsMappedKey(K))
    return OmitFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return OmitFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(OmitResolve(T, I), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/import/type/omit/omit-from-mapped-key.mjs
function FromPropertyKey(T, K, options) {
  return {
    [K]: Omit(T, [K], options)
  };
}
function FromPropertyKeys(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey(T, LK, options) };
  }, {});
}
function FromMappedKey(T, K, options) {
  return FromPropertyKeys(T, K.keys, options);
}
function OmitFromMappedKey(T, K, options) {
  const P = FromMappedKey(T, K, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/parameters/parameters.mjs
function Parameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}

// node_modules/@sinclair/typebox/build/import/type/partial/partial.mjs
function FromRest4(T) {
  return T.map((L) => PartialResolve(L));
}
function FromProperties7(T) {
  return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K) => {
    return { ...Acc, [K]: Optional(T[K]) };
  }, {});
}
function PartialResolve(T) {
  return IsIntersect(T) ? Intersect(FromRest4(T.allOf)) : IsUnion(T) ? Union(FromRest4(T.anyOf)) : IsObject2(T) ? Object(FromProperties7(T.properties)) : Object({});
}
function Partial(T, options = {}) {
  if (IsMappedResult(T))
    return PartialFromMappedResult(T, options);
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PartialResolve(T), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/import/type/partial/partial-from-mapped-result.mjs
function FromProperties8(K, options) {
  return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Partial(K[K2], options) };
  }, {});
}
function FromMappedResult4(R, options) {
  return FromProperties8(R.properties, options);
}
function PartialFromMappedResult(R, options) {
  const P = FromMappedResult4(R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/pick/pick-from-mapped-result.mjs
function FromProperties9(P, K, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Pick(P[K2], K, options) };
  }, {});
}
function FromMappedResult5(R, K, options) {
  return FromProperties9(R.properties, K, options);
}
function PickFromMappedResult(R, K, options) {
  const P = FromMappedResult5(R, K, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/pick/pick.mjs
function FromIntersect4(T, K) {
  return T.map((T2) => PickResolve(T2, K));
}
function FromUnion4(T, K) {
  return T.map((T2) => PickResolve(T2, K));
}
function FromProperties10(T, K) {
  return K.reduce((Acc, K2) => {
    return K2 in T ? { ...Acc, [K2]: T[K2] } : Acc;
  }, {});
}
function PickResolve(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect4(T.allOf, K)) : IsUnion(T) ? Union(FromUnion4(T.anyOf, K)) : IsObject2(T) ? Object(FromProperties10(T.properties, K)) : Object({});
}
function Pick(T, K, options = {}) {
  if (IsMappedKey(K))
    return PickFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return PickFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PickResolve(T, I), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/import/type/pick/pick-from-mapped-key.mjs
function FromPropertyKey2(T, K, options) {
  return {
    [K]: Pick(T, [K], options)
  };
}
function FromPropertyKeys2(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey2(T, LK, options) };
  }, {});
}
function FromMappedKey2(T, K, options) {
  return FromPropertyKeys2(T, K.keys, options);
}
function PickFromMappedKey(T, K, options) {
  const P = FromMappedKey2(T, K, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional(schema) {
  return Readonly(Optional(schema));
}

// node_modules/@sinclair/typebox/build/import/type/record/record.mjs
function RecordCreateFromPattern(pattern, T, options) {
  return {
    ...options,
    [Kind]: "Record",
    type: "object",
    patternProperties: { [pattern]: CloneType(T) }
  };
}
function RecordCreateFromKeys(K, T, options) {
  const P = K.reduce((Acc, K2) => ({ ...Acc, [K2]: CloneType(T) }), {});
  return Object(P, { ...options, [Hint]: "Record" });
}
function FromTemplateLiteralKey(K, T, options) {
  return IsTemplateLiteralFinite(K) ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
}
function FromUnionKey(K, T, options) {
  return RecordCreateFromKeys(IndexPropertyKeys(Union(K)), T, options);
}
function FromLiteralKey(K, T, options) {
  return RecordCreateFromKeys([K.toString()], T, options);
}
function FromRegExpKey(K, T, options) {
  return RecordCreateFromPattern(K.source, T, options);
}
function FromStringKey(K, T, options) {
  const pattern = IsUndefined(K.pattern) ? PatternStringExact : K.pattern;
  return RecordCreateFromPattern(pattern, T, options);
}
function FromIntegerKey(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
}
function FromNumberKey(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
}
function Record(K, T, options = {}) {
  return IsUnion(K) ? FromUnionKey(K.anyOf, T, options) : IsTemplateLiteral(K) ? FromTemplateLiteralKey(K, T, options) : IsLiteral(K) ? FromLiteralKey(K.const, T, options) : IsInteger(K) ? FromIntegerKey(K, T, options) : IsNumber2(K) ? FromNumberKey(K, T, options) : IsRegExp(K) ? FromRegExpKey(K, T, options) : IsString2(K) ? FromStringKey(K, T, options) : Never(options);
}

// node_modules/@sinclair/typebox/build/import/type/recursive/recursive.mjs
var Ordinal = 0;
function Recursive(callback, options = {}) {
  if (IsUndefined(options.$id))
    options.$id = `T${Ordinal++}`;
  const thisType = callback({ [Kind]: "This", $ref: `${options.$id}` });
  thisType.$id = options.$id;
  return CloneType({ ...options, [Hint]: "Recursive", ...thisType });
}

// node_modules/@sinclair/typebox/build/import/type/ref/ref.mjs
function Ref(unresolved, options = {}) {
  if (IsString(unresolved))
    return { ...options, [Kind]: "Ref", $ref: unresolved };
  if (IsUndefined(unresolved.$id))
    throw new Error("Reference target type must specify an $id");
  return {
    ...options,
    [Kind]: "Ref",
    $ref: unresolved.$id
  };
}

// node_modules/@sinclair/typebox/build/import/type/regexp/regexp.mjs
function RegExp(unresolved, options = {}) {
  const expr = IsString(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return { ...options, [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags };
}

// node_modules/@sinclair/typebox/build/import/type/required/required.mjs
function FromRest5(T) {
  return T.map((L) => RequiredResolve(L));
}
function FromProperties11(T) {
  return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K) => {
    return { ...Acc, [K]: Discard(T[K], [OptionalKind]) };
  }, {});
}
function RequiredResolve(T) {
  return IsIntersect(T) ? Intersect(FromRest5(T.allOf)) : IsUnion(T) ? Union(FromRest5(T.anyOf)) : IsObject2(T) ? Object(FromProperties11(T.properties)) : Object({});
}
function Required(T, options = {}) {
  if (IsMappedResult(T)) {
    return RequiredFromMappedResult(T, options);
  } else {
    const D = Discard(T, [TransformKind, "$id", "required"]);
    const R = CloneType(RequiredResolve(T), options);
    return { ...D, ...R };
  }
}

// node_modules/@sinclair/typebox/build/import/type/required/required-from-mapped-result.mjs
function FromProperties12(P, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Required(P[K2], options) };
  }, {});
}
function FromMappedResult6(R, options) {
  return FromProperties12(R.properties, options);
}
function RequiredFromMappedResult(R, options) {
  const P = FromMappedResult6(R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/rest/rest.mjs
function RestResolve(T) {
  return IsIntersect(T) ? [...T.allOf] : IsUnion(T) ? [...T.anyOf] : IsTuple(T) ? [...T.items ?? []] : [];
}
function Rest(T) {
  return CloneRest(RestResolve(T));
}

// node_modules/@sinclair/typebox/build/import/type/return-type/return-type.mjs
function ReturnType(schema, options = {}) {
  return CloneType(schema.returns, options);
}

// node_modules/@sinclair/typebox/build/import/type/strict/strict.mjs
function Strict(schema) {
  return JSON.parse(JSON.stringify(schema));
}

// node_modules/@sinclair/typebox/build/import/type/transform/transform.mjs
var TransformDecodeBuilder = class {
  constructor(schema) {
    __publicField(this, "schema");
    this.schema = schema;
  }
  Decode(decode) {
    return new TransformEncodeBuilder(this.schema, decode);
  }
};
var TransformEncodeBuilder = class {
  constructor(schema, decode) {
    __publicField(this, "schema");
    __publicField(this, "decode");
    this.schema = schema;
    this.decode = decode;
  }
  EncodeTransform(encode, schema) {
    const Encode = (value) => schema[TransformKind].Encode(encode(value));
    const Decode = (value) => this.decode(schema[TransformKind].Decode(value));
    const Codec = { Encode, Decode };
    return { ...schema, [TransformKind]: Codec };
  }
  EncodeSchema(encode, schema) {
    const Codec = { Decode: this.decode, Encode: encode };
    return { ...schema, [TransformKind]: Codec };
  }
  Encode(encode) {
    const schema = CloneType(this.schema);
    return IsTransform(schema) ? this.EncodeTransform(encode, schema) : this.EncodeSchema(encode, schema);
  }
};
function Transform(schema) {
  return new TransformDecodeBuilder(schema);
}

// node_modules/@sinclair/typebox/build/import/type/void/void.mjs
function Void(options = {}) {
  return {
    ...options,
    [Kind]: "Void",
    type: "void"
  };
}

// node_modules/@sinclair/typebox/build/import/type/type/json.mjs
var JsonTypeBuilder = class {
  // ------------------------------------------------------------------------
  // Strict
  // ------------------------------------------------------------------------
  /** `[Json]` Omits compositing symbols from this schema */
  Strict(schema) {
    return Strict(schema);
  }
  // ------------------------------------------------------------------------
  // Modifiers
  // ------------------------------------------------------------------------
  /** `[Json]` Creates a Readonly and Optional property */
  ReadonlyOptional(schema) {
    return ReadonlyOptional(schema);
  }
  /** `[Json]` Creates a Readonly property */
  Readonly(schema, enable) {
    return Readonly(schema, enable ?? true);
  }
  /** `[Json]` Creates a Optional property */
  Optional(schema, enable) {
    return Optional(schema, enable ?? true);
  }
  // ------------------------------------------------------------------------
  // Types
  // ------------------------------------------------------------------------
  /** `[Json]` Creates an Any type */
  Any(options = {}) {
    return Any(options);
  }
  /** `[Json]` Creates an Array type */
  Array(schema, options = {}) {
    return Array(schema, options);
  }
  /** `[Json]` Creates a Boolean type */
  Boolean(options = {}) {
    return Boolean(options);
  }
  /** `[Json]` Intrinsic function to Capitalize LiteralString types */
  Capitalize(schema, options = {}) {
    return Capitalize(schema, options);
  }
  /** `[Json]` Creates a Composite object type */
  Composite(schemas, options) {
    return Composite(schemas, options);
  }
  /** `[JavaScript]` Creates a readonly const type from the given value. */
  Const(value, options = {}) {
    return Const(value, options);
  }
  /** `[Json]` Creates a dereferenced type */
  Deref(schema, references) {
    return Deref(schema, references);
  }
  /** `[Json]` Creates a Enum type */
  Enum(item, options = {}) {
    return Enum(item, options);
  }
  /** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */
  Exclude(unionType, excludedMembers, options = {}) {
    return Exclude(unionType, excludedMembers, options);
  }
  /** `[Json]` Creates a Conditional type */
  Extends(L, R, T, F, options = {}) {
    return Extends(L, R, T, F, options);
  }
  /** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */
  Extract(type, union, options = {}) {
    return Extract(type, union, options);
  }
  /** `[Json]` Returns an Indexed property type for the given keys */
  Index(schema, unresolved, options = {}) {
    return Index(schema, unresolved, options);
  }
  /** `[Json]` Creates an Integer type */
  Integer(options = {}) {
    return Integer(options);
  }
  /** `[Json]` Creates an Intersect type */
  Intersect(T, options = {}) {
    return Intersect(T, options);
  }
  /** `[Json]` Creates a KeyOf type */
  KeyOf(schema, options = {}) {
    return KeyOf(schema, options);
  }
  /** `[Json]` Creates a Literal type */
  Literal(value, options = {}) {
    return Literal(value, options);
  }
  /** `[Json]` Intrinsic function to Lowercase LiteralString types */
  Lowercase(schema, options = {}) {
    return Lowercase(schema, options);
  }
  /** `[Json]` Creates a Mapped object type */
  Mapped(key, map, options = {}) {
    return Mapped(key, map, options);
  }
  /** `[Json]` Creates a Never type */
  Never(options = {}) {
    return Never(options);
  }
  /** `[Json]` Creates a Not type */
  Not(schema, options) {
    return Not(schema, options);
  }
  /** `[Json]` Creates a Null type */
  Null(options = {}) {
    return Null(options);
  }
  /** `[Json]` Creates a Number type */
  Number(options = {}) {
    return Number(options);
  }
  /** `[Json]` Creates an Object type */
  Object(properties, options = {}) {
    return Object(properties, options);
  }
  /** `[Json]` Constructs a type whose keys are omitted from the given type */
  Omit(schema, unresolved, options = {}) {
    return Omit(schema, unresolved, options);
  }
  /** `[Json]` Constructs a type where all properties are optional */
  Partial(schema, options = {}) {
    return Partial(schema, options);
  }
  /** `[Json]` Constructs a type whose keys are picked from the given type */
  Pick(schema, unresolved, options = {}) {
    return Pick(schema, unresolved, options);
  }
  /** `[Json]` Creates a Record type */
  Record(key, schema, options = {}) {
    return Record(key, schema, options);
  }
  /** `[Json]` Creates a Recursive type */
  Recursive(callback, options = {}) {
    return Recursive(callback, options);
  }
  /** `[Json]` Creates a Ref type. */
  Ref(unresolved, options = {}) {
    return Ref(unresolved, options);
  }
  /** `[Json]` Constructs a type where all properties are required */
  Required(schema, options = {}) {
    return Required(schema, options);
  }
  /** `[Json]` Extracts interior Rest elements from Tuple, Intersect and Union types */
  Rest(schema) {
    return Rest(schema);
  }
  /** `[Json]` Creates a String type */
  String(options = {}) {
    return String(options);
  }
  /** `[Json]` Creates a TemplateLiteral type */
  TemplateLiteral(unresolved, options = {}) {
    return TemplateLiteral(unresolved, options);
  }
  /** `[Json]` Creates a Transform type */
  Transform(schema) {
    return Transform(schema);
  }
  /** `[Json]` Creates a Tuple type */
  Tuple(items, options = {}) {
    return Tuple(items, options);
  }
  /** `[Json]` Intrinsic function to Uncapitalize LiteralString types */
  Uncapitalize(schema, options = {}) {
    return Uncapitalize(schema, options);
  }
  /** `[Json]` Creates a Union type */
  Union(schemas, options = {}) {
    return Union(schemas, options);
  }
  /** `[Json]` Creates an Unknown type */
  Unknown(options = {}) {
    return Unknown(options);
  }
  /** `[Json]` Creates a Unsafe type that will infers as the generic argument T */
  Unsafe(options = {}) {
    return Unsafe(options);
  }
  /** `[Json]` Intrinsic function to Uppercase LiteralString types */
  Uppercase(schema, options = {}) {
    return Uppercase(schema, options);
  }
};

// node_modules/@sinclair/typebox/build/import/type/type/type.mjs
var type_exports3 = {};
__export(type_exports3, {
  Any: () => Any,
  Array: () => Array,
  AsyncIterator: () => AsyncIterator,
  Awaited: () => Awaited,
  BigInt: () => BigInt,
  Boolean: () => Boolean,
  Capitalize: () => Capitalize,
  Composite: () => Composite,
  Const: () => Const,
  Constructor: () => Constructor,
  ConstructorParameters: () => ConstructorParameters,
  Date: () => Date,
  Deref: () => Deref,
  Enum: () => Enum,
  Exclude: () => Exclude,
  Extends: () => Extends,
  Extract: () => Extract,
  Function: () => Function,
  Index: () => Index,
  InstanceType: () => InstanceType,
  Integer: () => Integer,
  Intersect: () => Intersect,
  Iterator: () => Iterator,
  KeyOf: () => KeyOf,
  Literal: () => Literal,
  Lowercase: () => Lowercase,
  Mapped: () => Mapped,
  Never: () => Never,
  Not: () => Not,
  Null: () => Null,
  Number: () => Number,
  Object: () => Object,
  Omit: () => Omit,
  Optional: () => Optional,
  Parameters: () => Parameters,
  Partial: () => Partial,
  Pick: () => Pick,
  Promise: () => Promise2,
  Readonly: () => Readonly,
  ReadonlyOptional: () => ReadonlyOptional,
  Record: () => Record,
  Recursive: () => Recursive,
  Ref: () => Ref,
  RegExp: () => RegExp,
  Required: () => Required,
  Rest: () => Rest,
  ReturnType: () => ReturnType,
  Strict: () => Strict,
  String: () => String,
  Symbol: () => Symbol,
  TemplateLiteral: () => TemplateLiteral,
  Transform: () => Transform,
  Tuple: () => Tuple,
  Uint8Array: () => Uint8Array,
  Uncapitalize: () => Uncapitalize,
  Undefined: () => Undefined,
  Union: () => Union,
  Unknown: () => Unknown,
  Unsafe: () => Unsafe,
  Uppercase: () => Uppercase,
  Void: () => Void
});

// node_modules/@sinclair/typebox/build/import/type/type/javascript.mjs
var JavaScriptTypeBuilder = class extends JsonTypeBuilder {
  /** `[JavaScript]` Creates a AsyncIterator type */
  AsyncIterator(items, options = {}) {
    return AsyncIterator(items, options);
  }
  /** `[JavaScript]` Constructs a type by recursively unwrapping Promise types */
  Awaited(schema, options = {}) {
    return Awaited(schema, options);
  }
  /** `[JavaScript]` Creates a BigInt type */
  BigInt(options = {}) {
    return BigInt(options);
  }
  /** `[JavaScript]` Extracts the ConstructorParameters from the given Constructor type */
  ConstructorParameters(schema, options = {}) {
    return ConstructorParameters(schema, options);
  }
  /** `[JavaScript]` Creates a Constructor type */
  Constructor(parameters, returns, options) {
    return Constructor(parameters, returns, options);
  }
  /** `[JavaScript]` Creates a Date type */
  Date(options = {}) {
    return Date(options);
  }
  /** `[JavaScript]` Creates a Function type */
  Function(parameters, returns, options) {
    return Function(parameters, returns, options);
  }
  /** `[JavaScript]` Extracts the InstanceType from the given Constructor type */
  InstanceType(schema, options = {}) {
    return InstanceType(schema, options);
  }
  /** `[JavaScript]` Creates an Iterator type */
  Iterator(items, options = {}) {
    return Iterator(items, options);
  }
  /** `[JavaScript]` Extracts the Parameters from the given Function type */
  Parameters(schema, options = {}) {
    return Parameters(schema, options);
  }
  /** `[JavaScript]` Creates a Promise type */
  Promise(item, options = {}) {
    return Promise2(item, options);
  }
  /** `[JavaScript]` Creates a RegExp type */
  RegExp(unresolved, options = {}) {
    return RegExp(unresolved, options);
  }
  /** `[JavaScript]` Extracts the ReturnType from the given Function type */
  ReturnType(schema, options = {}) {
    return ReturnType(schema, options);
  }
  /** `[JavaScript]` Creates a Symbol type */
  Symbol(options) {
    return Symbol(options);
  }
  /** `[JavaScript]` Creates a Undefined type */
  Undefined(options = {}) {
    return Undefined(options);
  }
  /** `[JavaScript]` Creates a Uint8Array type */
  Uint8Array(options = {}) {
    return Uint8Array(options);
  }
  /** `[JavaScript]` Creates a Void type */
  Void(options = {}) {
    return Void(options);
  }
};

// node_modules/@sinclair/typebox/build/import/type/type/index.mjs
var Type = type_exports3;
export {
  Any,
  Array,
  AsyncIterator,
  Awaited,
  BigInt,
  Boolean,
  Capitalize,
  Clone,
  CloneRest,
  CloneType,
  Composite,
  Const,
  Constructor,
  ConstructorParameters,
  Date,
  Deref,
  Enum,
  Exclude,
  ExcludeFromMappedResult,
  ExcludeFromTemplateLiteral,
  Extends,
  ExtendsCheck,
  ExtendsFromMappedKey,
  ExtendsFromMappedResult,
  ExtendsResolverError,
  ExtendsResult,
  ExtendsUndefinedCheck,
  Extract,
  ExtractFromMappedResult,
  ExtractFromTemplateLiteral,
  format_exports as FormatRegistry,
  Function,
  Hint,
  Increment,
  Index,
  IndexFromMappedKey,
  IndexFromMappedResult,
  IndexFromPropertyKey,
  IndexFromPropertyKeys,
  IndexPropertyKeys,
  InstanceType,
  Integer,
  Intersect,
  IntersectEvaluated,
  Intrinsic,
  IntrinsicFromMappedKey,
  IsTemplateLiteralExpressionFinite,
  IsTemplateLiteralFinite,
  Iterator,
  JavaScriptTypeBuilder,
  JsonTypeBuilder,
  KeyOf,
  KeyOfFromMappedResult,
  KeyOfPattern,
  KeyOfPropertyKeys,
  KeyOfPropertyKeysToRest,
  Kind,
  Literal,
  Lowercase,
  Mapped,
  MappedFunctionReturnType,
  MappedKey,
  MappedResult,
  Never,
  Not,
  Null,
  Number,
  Object,
  Omit,
  OmitFromMappedKey,
  OmitFromMappedResult,
  Optional,
  OptionalFromMappedResult,
  OptionalKind,
  Parameters,
  Partial,
  PartialFromMappedResult,
  PatternBoolean,
  PatternBooleanExact,
  PatternNumber,
  PatternNumberExact,
  PatternString,
  PatternStringExact,
  Pick,
  PickFromMappedKey,
  PickFromMappedResult,
  Promise2 as Promise,
  Readonly,
  ReadonlyFromMappedResult,
  ReadonlyKind,
  ReadonlyOptional,
  Record,
  Recursive,
  Ref,
  RegExp,
  Required,
  RequiredFromMappedResult,
  Rest,
  ReturnType,
  SetComplement,
  SetDistinct,
  SetIncludes,
  SetIntersect,
  SetIntersectMany,
  SetIsSubset,
  SetUnion,
  SetUnionMany,
  Strict,
  String,
  Symbol,
  TemplateLiteral,
  TemplateLiteralExpressionGenerate,
  TemplateLiteralFiniteError,
  TemplateLiteralGenerate,
  TemplateLiteralGenerateError,
  TemplateLiteralParse,
  TemplateLiteralParseExact,
  TemplateLiteralParserError,
  TemplateLiteralPattern,
  TemplateLiteralPatternError,
  TemplateLiteralSyntax,
  TemplateLiteralToUnion,
  Transform,
  TransformDecodeBuilder,
  TransformEncodeBuilder,
  TransformKind,
  Tuple,
  Type,
  TypeBoxError,
  type_exports2 as TypeGuard,
  type_exports as TypeRegistry,
  Uint8Array,
  Uncapitalize,
  Undefined,
  Union,
  UnionEvaluated,
  Unknown,
  Unsafe,
  Uppercase,
  value_exports as ValueGuard,
  Void
};
//# sourceMappingURL=import-B734Z75O.js.map
